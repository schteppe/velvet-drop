{"ec753437ce7a49219cdc893908328c69.scene": {"modified": "2016-10-05T09:07:29.983230+00:00", "canvas": {"resolution": {"width": 970, "height": 900}, "mode": "Stretch", "aspect": {"width": 4, "height": 3}}, "initialCameraRef": "78de32fcb665490da74753058d21f162.entity", "name": "Velvet Drop", "license": "PRIVATE", "thumbnailRef": "b5b026ff0c36705903ca9405b4e7854ae9850e0e.jpg", "deleted": false, "tags": {}, "environmentRef": "cd97715a811c4beaaa5a5fa2fcb96fa6.environment", "dataModelVersion": 2, "originalAsset": {"version": "f35c71d076e34b1b949704442d5930a3", "id": "7cc549f153c441c4be95299dd9ee355d"}, "id": "ec753437ce7a49219cdc893908328c69.scene", "published": "2016-10-05T09:05:31.076044+00:00", "entities": {"43bf7dd8e2e24b05a1438c4c9bd38de2.entity": {"entityRef": "43bf7dd8e2e24b05a1438c4c9bd38de2.entity", "sortValue": 5}, "78de32fcb665490da74753058d21f162.entity": {"entityRef": "78de32fcb665490da74753058d21f162.entity", "sortValue": 13}, "f957bf5d95ef489e9490e0ff59ffa1ce.entity": {"entityRef": "f957bf5d95ef489e9490e0ff59ffa1ce.entity", "sortValue": 15}, "5b48b55d28ec414187280d095d24aa8e.entity": {"entityRef": "5b48b55d28ec414187280d095d24aa8e.entity", "sortValue": 16}}, "created": "2016-10-05T09:04:38.613777+00:00", "posteffectsRef": "ed658b2ea2ed4f9784ad6420cd7ffca2.posteffects", "editorCameraSettings": {"camera3d": {"spherical": [4, 1.4153981633974488, 0.18359877559829862], "lookAtPoint": [0, 0, 0]}, "camera2d": {"spherical": [2, 3.141592653589793, 0], "lookAtPoint": [0, 0, 0]}}, "packs": {"46fc53e2d520407da18f1928c80e34b3.pack": {"packRef": "46fc53e2d520407da18f1928c80e34b3.pack", "sortValue": 0}, "51b7af082101429cb4395c7963462975.pack": {"packRef": "51b7af082101429cb4395c7963462975.pack", "sortValue": 1}}, "defaultPackRef": "46fc53e2d520407da18f1928c80e34b3.pack", "publishedUrl": "https://c1.goote.ch/ec753437ce7a49219cdc893908328c69.scene", "assets": {"a799b480a5174dde95fda4d7a856e00e.texture": {"sortValue": 0, "assetRef": "a799b480a5174dde95fda4d7a856e00e.texture"}}}, "0ea623cf941242e3a09da5adbf8fb299.script": {"body": "var advancedSettings = false;\n\n// Use GPU or JavaScript?\nvar useGpu = false;\nfunction browserSupported(){\n\tvar agent = navigator.userAgent;\n\t\n\tif(\n\t\t// Firefox 35 on windows seem to have some kind of round off error or sth in the shader\n\t\t(agent.indexOf('Windows') !== -1 && agent.indexOf('Firefox/35') !== -1) ||\n\t\t\n\t\t// Adroid phones should use JS fallback too\n\t\t(agent.indexOf('Android') !== -1)\n\t){\n\t\treturn false;\n\t}\n\t\n\treturn true;\n}\n\nfunction hasFloatTextures(gl){\n\t\n\t// setup the texture\n\tvar texture = gl.createTexture();\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\tgl.texImage2D(\n\t\tgl.TEXTURE_2D,\n\t\t0,\n\t\tgl.RGBA,\n\t\t2, 2, // width and height\n\t\t0,\n\t\tgl.RGBA,\n\t\tgl.FLOAT, // or halfFloat.HALF_FLOAT_OES\n\t\tnull\n\t);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\n\t// setup the framebuffer\n\tvar framebuffer = gl.createFramebuffer();\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\tgl.framebufferTexture2D(\n\t\tgl.FRAMEBUFFER,\n\t\tgl.COLOR_ATTACHMENT0,\n\t\tgl.TEXTURE_2D, \n\t\ttexture,\n\t\t0\n\t);\n\t\n\t// check the framebuffer\n\tvar check = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\t\n\t// cleanup\n\tgl.deleteTexture(texture);\n\tgl.deleteFramebuffer(framebuffer);\n\tgl.bindTexture(gl.TEXTURE_2D, null);\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t\n\treturn check == gl.FRAMEBUFFER_COMPLETE;\n}\n\nfunction createClothEntity(world, quadEntity, meshData, material){\n\t\n\tvar entityMat = quadEntity.meshRendererComponent.materials[0];\n\t\n\tvar copyProps = [\n\t\t\"cullState\",\n\t\t\"blendState\",\n\t\t\"depthState\",\n\t\t\"dualTransparency\",\n\t\t\"uniforms\",\n\t\t\"wireframe\",\n\t\t\"flat\",\n\t\t\"renderQueue\"\n\t];\n\tfor(var i=0; i<copyProps.length; i++){\n\t\tvar prop = copyProps[i];\n\t\tmaterial[prop] = JSON.parse(JSON.stringify(entityMat[prop]));\n\t}\n\t\n\t// Copy over all textures\n\tvar maps = quadEntity.meshRendererComponent.materials[0].getTextureEntries();\n\tfor(var mapName in maps){\n\t\tmaterial.setTexture(mapName, maps[mapName]);\n\t}\n\tvar entity = world.createEntity(meshData, material).addToWorld();\n\tentity.meshRendererComponent.cullMode = 'Never';\n\n\tquadEntity.meshRendererComponent.hidden = true;\n\t\n\treturn entity;\n}\n\nvar getParticleInitialPosition = function(\n\tgoo,\n\tquadEntity,\n\tquadScale,\n\tx,\n\ty,\n\tsizeX, \n\tsizeY,\n\trestLengthX,\n\trestLengthY,\n\tfoldFactor,\n\tworldPosition\n){\n\tvar vec = new goo.Vector3();\n\tvar localTransform = new goo.Transform();\n\tvar localPosition = new goo.Vector3();\n\t\n\tlocalTransform.setIdentity();\n\tlocalTransform.setRotationXYZ(0, -Math.PI / 2, 0);\n\n\t// folding\n\tvar foldAngle = Math.PI / 2 * (1 - foldFactor);\n\tlocalPosition.x = y % 2 == 1 ? Math.cos(foldAngle) * restLengthY : 0;\n\n\tlocalPosition.z = (sizeX - 1) / 2 * restLengthX - x * restLengthX;\n\tlocalPosition.y = (sizeY - 1) / 2 * restLengthY - y * restLengthY * Math.sin(foldAngle);\n\tlocalPosition.z /= quadScale.x;\n\tlocalPosition.y /= quadScale.y;\n\t\t\n\tlocalTransform.update();\n\tlocalTransform.applyForward(localPosition, localPosition);\n\t\n\tquadEntity.transformComponent.worldTransform.applyForward(localPosition, worldPosition);\n\t\n\treturn worldPosition;\n}\n\n\nvar setup = function(args, ctx, goo) {\n\t\n\tif(!advancedSettings){\n\t\tvar preset = setup.presets[args.type].params;\n\t\tfor(var key in preset){\n\t\t\targs[key] = preset[key];\n\t\t}\n\t\targs.detach_time = args.js_detach_time = args.detach ? 10 : -1;\n\t\t\n\t\tif(args.detach){\n\t\t\targs.sleepTimeout = args.js_sleepTimeout = 30; // just to be safe\n\t\t}\n\t}\n\t\n\tctx.currentSize = args.size;\n\tctx.currentFoldFactor = args.foldFactor;\n\tctx.currentSleepTimeout = args.sleepTimeout;\n\t\n\tctx.listeners = {};\n\t\n\tvar quad = ctx.entity.meshDataComponent.meshData;\n\tif(!(quad instanceof goo.Quad)){\n\t\tthrow new Error('The Cloth Script only works with Quads.');\n\t}\n\t\n\tswitch(args.fallbackMode){\t\n\tcase 'forceJS':\n\t\tuseGpu = false;\n\t\tbreak;\n\tcase 'forceGPU':\n\t\tuseGpu = true;\n\t\tbreak;\n\tdefault:\n\t\tuseGpu = browserSupported() && hasFloatTextures(ctx.world.gooRunner.renderer.context);\n\t\tbreak;\n\t}\n\t\n\t// Copy all parameters if both modes should use same\n\tif(args.parameterMode === 'same'){\n\t\tfor(var argName in args){\n\t\t\tif(argName.indexOf('js_') === -1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Size parameters are not the same for JS and GPU\n\t\t\tswitch(argName){\n\t\t\tcase 'js_sizeX':\n\t\t\tcase 'js_sizeY':\n\t\t\t\targs.js_sizeY = args.js_sizeX = args.size;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Just copy e.g. args.js_abc = args.abc\n\t\t\t\targs[argName] = args[argName.replace('js_','')];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Unpack classes\n\tvar Camera = goo.Camera;\n\tvar CameraComponent = goo.CameraComponent;\n\tvar DirectionalLight = goo.DirectionalLight;\n\tvar EntityUtils = goo.EntityUtils;\n\tvar FullscreenUtil = goo.FullscreenUtil;\n\tvar LightComponent = goo.LightComponent;\n\tvar Material = goo.Material;\n\tvar MathUtils = goo.MathUtils;\n\tvar MeshData = goo.MeshData;\n\tvar MeshRendererComponent = goo.MeshRendererComponent;\n\tvar OrbitCamControlScript = goo.OrbitCamControlScript;\n\tvar RenderTarget = goo.RenderTarget;\n\tvar Shader = goo.Shader;\n\tvar ShaderBuilder = goo.ShaderBuilder;\n\tvar ShaderLib = goo.ShaderLib;\n\tvar Texture = goo.Texture;\n\tvar TextureCreator = goo.TextureCreator;\n\tvar Transform = goo.Transform;\n\tvar Vector3 = goo.Vector3;\n\n\tvar RNG = function(seed) {\n\t\t// c rand\n\t\tthis.a = 214013;\n\t\tthis.c = 2531011;\n\t\tthis.m = 32768;\n\t\tthis.state = typeof seed !== 'undefined' ? seed : Math.floor(Math.random() * this.m);\n\t}\n\tRNG.prototype.nextInt = function (start, end) {\n\t\tthis.state = (this.state * this.a + this.c) % this.m;\n\t\treturn this.state % (end - start + 1) + start;\n\t};\n\tRNG.prototype.nextFloat = function () {\n\t\tthis.state = (this.state * this.a + this.c) % this.m;\n\t\treturn this.state / this.m;\n\t};\n\tRNG.m = 32768;\n\tRNG.fromString = function (str) {\n\t\tvar seed = str.split('').map(function (char) {\n\t\t\treturn char.charCodeAt(0);\n\t\t}).reduce(function (prev, cur) {\n\t\t\treturn (prev + cur) % RNG.m;\n\t\t}, 0);\n\t\treturn new RNG(seed);\n\t};\n\t\n\tvar rng = new RNG(123.456);\n\n\tvar isStatic = function (attachmentMode, x, y, ctx, N){\n\t\tvar result = false;\n\t\tswitch(attachmentMode){\n\t\tcase \"None\":\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\tcase \"Full top\":\n\t\t\tresult = (y === 0);\n\t\t\tbreak;\n\t\tcase \"2 points at top\":\n\t\t\tresult = (y === 0 && (x === 0 || x == ctx.sizeX-1));\n\t\t\tbreak;\n\t\tcase \"3 points at top\":\n\t\t\tresult = (y === 0 && (x === 0 || x == ctx.sizeX-1 || x == Math.floor(ctx.sizeX/2)));\n\t\t\tbreak;\n\t\tcase \"N points at top\":\n\t\t\tif(y !== 0) break;\n\t\t\t\n\t\t\tvar dist = ctx.sizeX / (N-1);\n\t\t\tresult = (y === 0 && (x === 0 || x == ctx.sizeX-1));\n\t\t\tif(result) break;\n\t\t\t\n\t\t\tfor(var i=0; i<N; i++){\n\t\t\t\tif(Math.floor(dist * i) == x){\n\t\t\t\t\tresult = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\treturn result;\n\t}\n\n\t// Process transforms once - so we get updated positions for our cloth\n\tvar ts = ctx.world.getSystem('TransformSystem');\n\tts._activeEntities.forEach(function(entity){\n\t\tentity.transformComponent.setUpdated();\t\n\t});\n\tts.process(ts._activeEntities);\n\n\tif(useGpu){\n\t\tvar velocityInfo;\n\t\tvar positionInfo;\n\t\tvar velocityTexture;\n\t\tvar positionTexture;\n\t\tvar particleUpdateMaterial;\n\t\tvar particleUpdateVelocityMaterial;\n\t\tvar renderable;\n\t\tvar positionTarget1;\n\t\tvar positionTarget2;\n\t\tvar velocityTarget1;\n\t\tvar velocityTarget2;\n\t\tvar cursorX = -0.5;\n\t\tvar cursorY = -0.5;\n\t\t\n\t\tvar copyPass = new goo.FullscreenPass(goo.ShaderLib.screenCopy);\n\t\tcopyPass.material.depthState.enabled = false;\n\t\t\n\t\t// Compute size\n\t\tctx.sizeX = Math.pow(2, args.size);\n\t\tctx.sizeY = Math.pow(2, args.size);\n\t\n\t\tvar scale = ctx.entity.getScale();\n\t\tvar restLengthX = 2 * quad.xExtent * scale.x / (ctx.sizeX - 1);\n\t\tvar restLengthY = 2 * quad.yExtent * scale.y / (ctx.sizeY - 1);\n\t\t\n\t\tvar textureSettings = {\n\t\t\ttype: 'Float',\n\t\t\tminFilter: 'NearestNeighborNoMipMaps',\n\t\t\tmagFilter: 'NearestNeighbor',\n\t\t};\n\t\t\n\t\tvar setInitialPositions = function (){\n\t\t\tvar renderer = ctx.world.gooRunner.renderer;\n\t\t\t\n\t\t\tfillInfo(positionInfo, velocityInfo);\n\t\n\t\t\tpositionTexture.setImage(positionInfo, ctx.sizeX, ctx.sizeY, textureSettings);\n\t\t\tvelocityTexture.setImage(velocityInfo, ctx.sizeX, ctx.sizeY, textureSettings);\n\t\t\t\n\t\t\tcopyPass.render(renderer, positionTarget1, positionTexture);\n\t\t\tcopyPass.render(renderer, positionTarget2, positionTexture);\n\t\t\tcopyPass.render(renderer, velocityTarget1, velocityTexture);\n\t\t\tcopyPass.render(renderer, velocityTarget2, velocityTexture);\n\t\t}\n\t\n\t\tvar fillInfo = function (positionInfo, velocityInfo){\n\t\t\tvar worldPosition = new Vector3();\n\t\t\tfor (var x = 0; x < ctx.sizeX; x++) {\n\t\t\t\tfor (var y = 0; y < ctx.sizeY; y++) {\n\t\t\t\t\tvar i = y * ctx.sizeX + x;\n\t\t\t\t\t\n\t\t\t\t\tvar invMass = isStatic(args.attachmentMode, x, y, ctx, args.N) ? 0 : 1;\n\t\n\t\t\t\t\tgetParticleInitialPosition(\n\t\t\t\t\t\tgoo,\n\t\t\t\t\t\tctx.entity,\n\t\t\t\t\t\tscale,\n\t\t\t\t\t\tx,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\tctx.sizeX, \n\t\t\t\t\t\tctx.sizeY,\n\t\t\t\t\t\trestLengthX,\n\t\t\t\t\t\trestLengthY,\n\t\t\t\t\t\targs.foldFactor,\n\t\t\t\t\t\tworldPosition\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// position\n\t\t\t\t\tpositionInfo[i * 4 + 0] = worldPosition.x;\n\t\t\t\t\tpositionInfo[i * 4 + 1] = worldPosition.y;\n\t\t\t\t\tpositionInfo[i * 4 + 2] = worldPosition.z;\n\t\n\t\t\t\t\t// mass\n\t\t\t\t\tpositionInfo[i * 4 + 3] = invMass;\n\t\n\t\t\t\t\t// velocity\n\t\t\t\t\tvelocityInfo[i * 4 + 0] = (2 * rng.nextFloat() - 1) * args.velocityNoise[0];\n\t\t\t\t\tvelocityInfo[i * 4 + 1] = (2 * rng.nextFloat() - 1) * args.velocityNoise[1];\n\t\t\t\t\tvelocityInfo[i * 4 + 2] = (2 * rng.nextFloat() - 1) * args.velocityNoise[2];\n\t\n\t\t\t\t\t// mass\n\t\t\t\t\tvelocityInfo[i * 4 + 3] = invMass;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar fillMass = function (positionInfo, velocityInfo, invMass){\n\t\t\tfor (var x = 0; x < ctx.sizeX; x++) {\n\t\t\t\tfor (var y = 0; y < ctx.sizeY; y++) {\n\t\t\t\t\tvar i = y * ctx.sizeX + x;\n\t\t\t\t\t\n\t\t\t\t\t// mass\n\t\t\t\t\tpositionInfo[i * 4 + 3] = velocityInfo[i * 4 + 3] = invMass;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tvar particleDemo = function (gooRunner) {\n\t\n\t\t\tpositionTarget1 = new RenderTarget(ctx.sizeX, ctx.sizeY, textureSettings);\n\t\t\tpositionTarget2 = new RenderTarget(ctx.sizeX, ctx.sizeY, textureSettings);\n\t\t\tvelocityTarget1 = new RenderTarget(ctx.sizeX, ctx.sizeY, textureSettings);\n\t\t\tvelocityTarget2 = new RenderTarget(ctx.sizeX, ctx.sizeY, textureSettings);\n\t\n\t\t\tpositionInfo = new Float32Array(4 * ctx.sizeX * ctx.sizeY);\n\t\t\tvelocityInfo = new Float32Array(4 * ctx.sizeX * ctx.sizeY);\n\t\t\tfillInfo(positionInfo, velocityInfo);\n\t\n\t\t\tpositionTexture = new Texture(positionInfo, textureSettings, ctx.sizeX, ctx.sizeY);\n\t\t\tpositionTexture.generateMipmaps = false;\n\t\n\t\t\tvelocityTexture = new Texture(velocityInfo, textureSettings, ctx.sizeX, ctx.sizeY);\n\t\t\tvelocityTexture.generateMipmaps = false;\n\t\n\t\t\tparticleUpdateMaterial = new Material(particleUpdateShader);\n\t\t\tparticleUpdateVelocityMaterial = new Material(particleUpdateVelocityShader);\n\t\n\t\t\tvar sourcePosition = positionTexture;\n\t\t\tvar targetPosition = positionTarget2;\n\t\n\t\t\tvar sourceVelocity = velocityTexture;\n\t\t\tvar targetVelocity = velocityTarget2;\n\t\n\t\t\trenderable = {\n\t\t\t\tmeshData: FullscreenUtil.quad,\n\t\t\t\tmaterials: [],\n\t\t\t\ttransform: new Transform(),\n\t\t\t\tshaderCache: {}\n\t\t\t};\n\t\n\t\t\tvar particleEntity = ctx.particleEntity = createParticleEntity(goo, ctx.sizeX, ctx.sizeY);\n\t\t\tvar first = true;\n\t\n\t\t\tvar startTime = ctx.world.time;\n\t\t\tvar physicsTime = 0;\n\t\t\tvar running = args.autoStart;\n\t\t\tctx.callbackPreRender = function (tpf) {\n\t\t\t\tvar currentTime = ctx.world.time - startTime;\n\t\t\t\tif(args.sleepTimeout > 0 && currentTime > args.sleepTimeout){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(!running){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(first){\n\t\t\t\t\tsetInitialPositions();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar renderUniforms = particleEntity.meshRendererComponent.materials[0].uniforms;\n\t\n\t\t\t\tif(args.enableAnimation && !ctx.detached){\n\t\t\t\t\tsetFixedParticlePositions();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar velocityUniforms = particleUpdateVelocityMaterial.uniforms;\n\t\t\t\tvelocityUniforms.gx = args.gravity[0];\n\t\t\t\tvelocityUniforms.gy = args.gravity[1];\n\t\t\t\tvelocityUniforms.gz = args.gravity[2];\n\t\t\t\tvelocityUniforms.k = args.stiffness;\n\t\t\t\tvelocityUniforms.bendStiffness = args.bendStiffness;\n\t\t\t\tvelocityUniforms.damping = args.damping;\n\t\t\t\tvelocityUniforms.bendDamping = args.bendDamping;\n\t\t\t\tvar dt = 1 / args.stepFrequency;\n\t\t\t\tparticleUpdateMaterial.uniforms.dt = velocityUniforms.dt = dt;\n\t\n\t\t\t\tvelocityUniforms.invSizeX = 1 / ctx.sizeX;\n\t\t\t\tvelocityUniforms.invSizeY = 1 / ctx.sizeY;\n\t\t\t\tparticleUpdateMaterial.uniforms.forcePos = [\n\t\t\t\t\t-0.5,\n\t\t\t\t\t-cursorY * 50,\n\t\t\t\t\t-cursorX * 50\n\t\t\t\t];\n\t\t\t\t\n\t\t\t\t// Detach?\n\t\t\t\tif(!ctx.detached && args.detach_time > 0 && currentTime > args.detach_time){\n\t\t\t\t\tvelocityUniforms.setInvMass = 1;\n\t\t\t\t\tparticleUpdateMaterial.uniforms.setInvMass = 1;\n\t\t\t\t\tfillMass(positionInfo, velocityInfo, 1);\n\t\t\t\t\tctx.detached = true;\n\t\t\t\t\t\n\t\t\t\t\tgoo.SystemBus.emit('clothScript.detach');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Approx num steps needed\n\t\t\t\tvar subSteps = args.stepFrequency / 60;\n\t\t\t\tvar usedSubSteps = 0;\n\t\t\t\t//for(var i=0; i < subSteps; i++){\n\t\t\t\twhile(physicsTime < currentTime){\n\t\t\t\t\trenderable.materials[0] = particleUpdateVelocityMaterial;\n\t\t\t\t\tparticleUpdateVelocityMaterial.setTexture('DIFFUSE_MAP', sourceVelocity);\n\t\t\t\t\tparticleUpdateVelocityMaterial.setTexture('START_MAP', velocityTexture);\n\t\t\t\t\tparticleUpdateVelocityMaterial.setTexture('POS_MAP', sourcePosition);\n\t\t\t\t\tgooRunner.renderer.render(renderable, FullscreenUtil.camera, [], targetVelocity, false);\n\t\n\t\t\t\t\trenderable.materials[0] = particleUpdateMaterial;\n\t\t\t\t\tparticleUpdateMaterial.setTexture('DIFFUSE_MAP', sourcePosition);\n\t\t\t\t\tparticleUpdateMaterial.setTexture('START_MAP', positionTexture);\n\t\t\t\t\tparticleUpdateMaterial.setTexture('VELOCITY_MAP', targetVelocity);\n\t\t\t\t\tgooRunner.renderer.render(renderable, FullscreenUtil.camera, [], targetPosition, false);\n\t\n\t\t\t\t\tparticleEntity.meshRendererComponent.materials[0].setTexture('POS_MAP', targetPosition);\n\t\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tsourcePosition = positionTarget1;\n\t\t\t\t\t\tsourceVelocity = velocityTarget1;\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Swap!\n\t\t\t\t\tvar tmp = targetVelocity;\n\t\t\t\t\ttargetVelocity = sourceVelocity;\n\t\t\t\t\tsourceVelocity = tmp;\n\t\n\t\t\t\t\ttmp = targetPosition;\n\t\t\t\t\ttargetPosition = sourcePosition;\n\t\t\t\t\tsourcePosition = tmp;\n\t\t\t\t\t\n\t\t\t\t\tphysicsTime += dt;\n\t\t\t\t\tusedSubSteps++;\n\t\t\t\t\tif(usedSubSteps >= args.maxSubSteps){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tgooRunner.callbacksPreRender.push(ctx.callbackPreRender);\n\t\n\t\t\t// Things to clean up\n\t\t\tctx.targets = [\n\t\t\t\tpositionTarget1,\n\t\t\t\tpositionTarget2,\n\t\t\t\tvelocityTarget1,\n\t\t\t\tvelocityTarget2\n\t\t\t];\n\t\n\t\n\t\t\tif(!ctx.materials)\n\t\t\t\tctx.materials = [];\n\t\n\t\t\tctx.materials.push(\n\t\t\t\tparticleUpdateVelocityMaterial,\n\t\t\t\tparticleUpdateMaterial\n\t\t\t);\n\t\t\n\t\t\tif(!args.autoStart){\n\t\t\t\tctx.startListener = function(){\n\t\t\t\t\trunning = true;\n\t\t\t\t\tphysicsTime = 0;\n\t\t\t\t\tstartTime = ctx.world.time;\n\t\t\t\t}\n\t\t\t\tgoo.SystemBus.addListener('clothScript.start', ctx.startListener);\n\t\t\t}\n\t\t}\n\t\n\t\tvar createParticleEntity = function (goo, sizeX, sizeY) {\n\t\t\tvar count = sizeX * sizeY;\n\t\n\t\t\tvar attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.TEXCOORD0]);\n\t\t\tvar meshData = new MeshData(attributeMap, count, (sizeY - 1) * (sizeX - 1) * 2 * 3);\n\t\t\tmeshData.indexModes = ['Triangles'];\n\t\n\t\t\tvar verts = meshData.getAttributeBuffer(MeshData.POSITION);\n\t\t\tvar uvs = meshData.getAttributeBuffer(MeshData.TEXCOORD0);\n\t\t\tvar indices = [];\n\t\n\t\t\tfor (var x = 0; x < sizeX; x++) {\n\t\t\t\tfor (var y = 0; y < sizeY; y++) {\n\t\t\t\t\tvar i = y * sizeX + x;\n\t\n\t\t\t\t\tverts[i * 3 + 0] = 0;\n\t\t\t\t\tverts[i * 3 + 1] = 0;\n\t\t\t\t\tverts[i * 3 + 2] = 0;\n\t\n\t\t\t\t\tuvs[i * 2 + 0] = x / (sizeX - 1);\n\t\t\t\t\tuvs[i * 2 + 1] = y / (sizeY - 1);\n\t\n\t\t\t\t\tif(x == sizeX - 2 && y == sizeY - 2){\n\t\t\t\t\t\t// Lower triangle\n\t\t\t\t\t\tindices.push(\n\t\t\t\t\t\t\t(y + 0) * sizeX + (x + 0),\n\t\t\t\t\t\t\t(y + 1) * sizeX + (x + 1),\n\t\t\t\t\t\t\t(y + 0) * sizeX + (x + 1)\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Upper\n\t\t\t\t\t\tindices.push(\n\t\t\t\t\t\t\t(y + 1) * sizeX + (x + 1),\n\t\t\t\t\t\t\t(y + 0) * sizeX + (x + 0),\n\t\t\t\t\t\t\t(y + 1) * sizeX + (x + 0)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if(x < sizeX - 1 && y < sizeY - 1){\n\t\t\t\t\t\t// Lower triangle\n\t\t\t\t\t\tindices.push(\n\t\t\t\t\t\t\t(y + 0) * sizeX + (x + 0),\n\t\t\t\t\t\t\t(y + 1) * sizeX + (x + 0),\n\t\t\t\t\t\t\t(y + 0) * sizeX + (x + 1)\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Upper\n\t\t\t\t\t\tindices.push(\n\t\t\t\t\t\t\t(y + 1) * sizeX + (x + 1),\n\t\t\t\t\t\t\t(y + 0) * sizeX + (x + 1),\n\t\t\t\t\t\t\t(y + 1) * sizeX + (x + 0)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmeshData.getIndexBuffer().set(indices);\n\t\t\tvar material = new Material(newParticleShader);\n\t\t\t\n\t\t\tif(!ctx.materials)\n\t\t\t\tctx.materials = [];\n\t\t\tctx.materials.push(material);\n\t\t\t\n\t\t\treturn createClothEntity(ctx.world, ctx.entity, meshData, material);\n\t\t}\n\t\n\t\tvar init = function () {\n\t\t\tparticleDemo(ctx.world.gooRunner);\n\t\t}\n\t\t\n\t\tvar texturedMaterial = new Material({\n\t\t\tdefines: {\n\t\t\t\tTEXCOORD0: true,\n\t\t\t\tDIFFUSE_MAP: true\n\t\t\t},\n\t\t\tattributes : {\n\t\t\t\tvertexPosition : MeshData.POSITION,\n\t\t\t\tvertexUV0 : MeshData.TEXCOORD0\n\t\t\t},\n\t\t\tuniforms : {\n\t\t\t\tviewProjectionMatrix : Shader.VIEW_PROJECTION_MATRIX,\n\t\t\t\tworldMatrix : Shader.WORLD_MATRIX,\n\t\t\t\tdiffuseMap : Shader.DIFFUSE_MAP\n\t\t\t},\n\t\t\tvshader : [\n\t\t\t\t'attribute vec3 vertexPosition;',\n\t\t\t\t'attribute vec2 vertexUV0;',\n\t\n\t\t\t\t'uniform mat4 viewProjectionMatrix;',\n\t\t\t\t'uniform mat4 worldMatrix;',\n\t\n\t\t\t\t'varying vec2 texCoord0;',\n\t\n\t\t\t\t'void main(void) {',\n\t\t\t\t\t'texCoord0 = vertexUV0;',\n\t\t\t\t\t'gl_Position = viewProjectionMatrix * worldMatrix * vec4(vertexPosition, 1.0);',\n\t\t\t\t'}'\n\t\t\t].join('\\n'),\n\t\t\tfshader : [\n\t\t\t\t'uniform sampler2D diffuseMap;',\n\t\t\t\t'varying vec2 texCoord0;',\n\t\t\t\t'void main(void)',\n\t\t\t\t'{',\n\t\t\t\t\t'vec4 position = texture2D(diffuseMap, texCoord0);',\n\t\t\t\t\t'float invMass = position.w;',\n\t\t\t\t\t'if(invMass > 0.0){',\n\t\t\t\t\t'    discard;', // Keep old positions\n\t\t\t\t\t'}',\n\t\t\t\t\t'gl_FragColor = position;',\n\t\t\t\t'}'\n\t\t\t].join('\\n')\n\t\t});\n\t\t\n\t\tvar setAllMassesMaterial = new Material({\n\t\t\tdefines: {\n\t\t\t\tTEXCOORD0: true,\n\t\t\t\tDIFFUSE_MAP: true\n\t\t\t},\n\t\t\tattributes : {\n\t\t\t\tvertexPosition : MeshData.POSITION,\n\t\t\t\tvertexUV0 : MeshData.TEXCOORD0\n\t\t\t},\n\t\t\tuniforms : {\n\t\t\t\tviewProjectionMatrix : Shader.VIEW_PROJECTION_MATRIX,\n\t\t\t\tworldMatrix : Shader.WORLD_MATRIX,\n\t\t\t\tdiffuseMap : Shader.DIFFUSE_MAP,\n\t\t\t\tinvMass : 1\n\t\t\t},\n\t\t\tvshader : [\n\t\t\t\t'attribute vec3 vertexPosition;',\n\t\t\t\t'attribute vec2 vertexUV0;',\n\t\n\t\t\t\t'uniform mat4 viewProjectionMatrix;',\n\t\t\t\t'uniform mat4 worldMatrix;',\n\t\n\t\t\t\t'varying vec2 texCoord0;',\n\t\n\t\t\t\t'void main(void) {',\n\t\t\t\t\t'texCoord0 = vertexUV0;',\n\t\t\t\t\t'gl_Position = viewProjectionMatrix * worldMatrix * vec4(vertexPosition, 1.0);',\n\t\t\t\t'}'\n\t\t\t].join('\\n'),\n\t\t\tfshader : [\n\t\t\t\t'uniform float invMass;',\n\t\t\t\t'uniform sampler2D diffuseMap;',\n\t\t\t\t'varying vec2 texCoord0;',\n\t\t\t\t'void main(void)',\n\t\t\t\t'{',\n\t\t\t\t\t'vec4 position = texture2D(diffuseMap, texCoord0);',\n\t\t\t\t\t//'position.w = 1.0;',\n\t\t\t\t\t'gl_FragColor = position;',\n\t\t\t\t'}'\n\t\t\t].join('\\n')\n\t\t});\n\t\t\n\t\tvar setFixedParticlePositions = function (){\n\t\t\tfillInfo(positionInfo, velocityInfo);\n\t\n\t\t\tpositionTexture.setImage(positionInfo, ctx.sizeX, ctx.sizeY, textureSettings);\n\t\t\tpositionTexture.setNeedsUpdate();\n\t\n\t\t\trenderable.materials[0] = texturedMaterial;\n\t\n\t\t\ttexturedMaterial.setTexture('DIFFUSE_MAP', positionTexture); // Initial positions go into the diffuse map\n\t\t\tctx.world.gooRunner.renderer.render(renderable, goo.FullscreenUtil.camera, [], positionTarget1, false);\n\t\t\tctx.world.gooRunner.renderer.render(renderable, goo.FullscreenUtil.camera, [], positionTarget2, false);\n\t\t}\n\t\t/*\n\t\tvar detach = function (){\n\t\t\tfillMass(positionInfo, velocityInfo, 1);\n\t\t\t\n\t\t\trenderable.materials[0] = setAllMassesMaterial;\n\t\t\tsetAllMassesMaterial.shader.uniforms.invMass = 1;\n\t\t\tsetAllMassesMaterial.setTexture('DIFFUSE_MAP', positionTarget2);\n\t\t\tctx.world.gooRunner.renderer.render(renderable, goo.FullscreenUtil.camera, [], positionTarget1, false);\n\t\t\tsetAllMassesMaterial.setTexture('DIFFUSE_MAP', positionTarget1);\n\t\t\tctx.world.gooRunner.renderer.render(renderable, goo.FullscreenUtil.camera, [], positionTarget2, false);\n\t\t}*/\n\t\n\t\tvar particleUpdateVelocityShader = {\n\t\t\tattributes: {\n\t\t\t\tvertexPosition: MeshData.POSITION,\n\t\t\t\tvertexUV0: MeshData.TEXCOORD0\n\t\t\t},\n\t\t\tuniforms: {\n\t\t\t\tviewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,\n\t\t\t\tworldMatrix: Shader.WORLD_MATRIX,\n\t\t\t\tdiffuseMap: Shader.DIFFUSE_MAP,\n\t\t\t\tstartMap: 'START_MAP',\n\t\t\t\tposMap: 'POS_MAP',\n\t\t\t\ttpf: Shader.TPF,\n\t\t\t\tinvSizeX: 1 / ctx.sizeX,\n\t\t\t\tinvSizeY: 1 / ctx.sizeY,\n\t\t\t\tsizeX: ctx.sizeX,\n\t\t\t\tsizeY: ctx.sizeY,\n\t\t\t\tk: args.stiffness,\n\t\t\t\tbendStiffness: args.bendStiffness,\n\t\t\t\tbendDamping: args.bendDamping,\n\t\t\t\trestLengthX: restLengthX,\n\t\t\t\trestLengthY: restLengthY,\n\t\t\t\trestLen2: Math.sqrt(restLengthX * restLengthX + restLengthY * restLengthY),\n\t\t\t\tgx: args.gravity[0],\n\t\t\t\tgy: args.gravity[1],\n\t\t\t\tgz: args.gravity[2],\n\t\t\t\tdt: 1 / args.stepFrequency,\n\t\t\t\tdamping: args.damping,\n\t\t\t\tspatialDamping: args.spatialDamping,\n\t\t\t\trestLengthAspect: 1,\n\t\t\t\tsetInvMass: -1\n\t\t\t},\n\t\t\tvshader: [\n\t\t\t\t'precision highp float;',\n\t\t\t\t'attribute vec3 vertexPosition;',\n\t\t\t\t'attribute vec2 vertexUV0;',\n\t\n\t\t\t\t'uniform mat4 viewProjectionMatrix;',\n\t\t\t\t'uniform mat4 worldMatrix;',\n\t\n\t\t\t\t'varying vec2 vUv;',\n\t\n\t\t\t\t'void main() {',\n\t\t\t\t'   vUv = vertexUV0;',\n\t\t\t\t'   gl_Position = viewProjectionMatrix * worldMatrix * vec4(vertexPosition, 1.0);',\n\t\t\t\t'}'\n\t\t\t].join('\\n'),\n\t\t\tfshader: [\n\t\t\t\t'precision highp float;',\n\t\t\t\t'uniform sampler2D diffuseMap;',\n\t\t\t\t'uniform sampler2D startMap;',\n\t\t\t\t'uniform sampler2D posMap;',\n\t\t\t\t'uniform float setInvMass;',\n\t\t\t\t'uniform float tpf;',\n\t\t\t\t'uniform float invSizeX;',\n\t\t\t\t'uniform float invSizeY;',\n\t\t\t\t'uniform float sizeX;',\n\t\t\t\t'uniform float sizeY;',\n\t\t\t\t'uniform float k;',\n\t\t\t\t'uniform float bendStiffness;',\n\t\t\t\t'uniform float gx;',\n\t\t\t\t'uniform float gy;',\n\t\t\t\t'uniform float gz;',\n\t\t\t\t'uniform float restLengthX;',\n\t\t\t\t'uniform float restLengthY;',\n\t\t\t\t'uniform float restLen2;',\n\t\t\t\t'uniform float dt;',\n\t\t\t\t'uniform float damping;',\n\t\t\t\t'uniform float bendDamping;',\n\t\t\t\t'uniform float spatialDamping;',\n\t\t\t\t'uniform vec2 resolution;',\n\t\n\t\t\t\t'varying vec2 vUv;',\n\t\n\t\t\t\t'void main() {',\n\t\t\t\t'   float d = damping;',\n\t\t\t\t'   vec4 vel = texture2D(diffuseMap, vUv);',\n\t\t\t\t'   vec4 pos = texture2D(posMap, vUv);',\n\t\t\t\t'   vec3 v = vel.xyz;',\n\t\t\t\t'   vec3 p = pos.xyz;',\n\t\t\t\t'   float invMass = pos.w;',\n\t\t\t\t'   highp float minX = 0.0;',\n\t\t\t\t'   highp float minY = 0.0;',\n\t\t\t\t'   highp float maxX = (sizeX - 1.0);',\n\t\t\t\t'   highp float maxY = (sizeY - 1.0);',\n\t\t\t\t'   vec3 force = vec3(gx, gy, gz);',\n\t\t\t\t'   vec2 flooredFragCoord = vec2(floor(gl_FragCoord.x), floor(gl_FragCoord.y));',\n\t\t\t\t\n\t\t\t\t'   if(setInvMass >= 0.0){',\n\t\t\t\t'       invMass = 1.0;',\n\t\t\t\t'       pos.w = 1.0;',\n\t\t\t\t'   }',\n\t\t\t\t\n\t\t\t\t// TODO: avoid if/else branching\n\t\t\t\t\n\t\t\t\t// +y\n\t\t\t\t'   if(floor(gl_FragCoord.y) < maxY){',\n\t\t\t\t'       vec2 uv = vUv + vec2(0, invSizeY);',\n\t\t\t\t'   \tvec3 dist = pos.xyz - texture2D(posMap, uv).xyz;',\n\t\t\t\t'   \tvec3 relVel = vel.xyz - texture2D(diffuseMap, uv).xyz;',\n\t\t\t\t'       vec3 ndist = normalize(dist);',\n\t\t\t\t'   \tforce += (- k * (length(dist) - restLengthY) - d * dot(relVel, ndist)) * ndist;',\n\t\t\t\t'\t}',\n\t\n\t\t\t\t// -y\n\t\t\t\t'   if(floor(gl_FragCoord.y) > minY){',\n\t\t\t\t'       vec2 uv = vUv + vec2(0, -invSizeY);',\n\t\t\t\t'   \tvec3 dist = pos.xyz - texture2D(posMap, uv).xyz;',\n\t\t\t\t'   \tvec3 relVel = vel.xyz - texture2D(diffuseMap, uv).xyz;',\n\t\t\t\t'       vec3 ndist = normalize(dist);',\n\t\t\t\t'   \tforce += (- k * (length(dist) - restLengthY) - d * dot(relVel, ndist)) * ndist;',\n\t\t\t\t'\t}',\n\t\n\t\t\t\t// +x\n\t\t\t\t'\tif(floor(gl_FragCoord.x) < maxX){',\n\t\t\t\t'       vec2 uv = vUv + vec2(invSizeX, 0);',\n\t\t\t\t'  \t\tvec3 dist = pos.xyz - texture2D(posMap, uv).xyz;',\n\t\t\t\t'   \tvec3 relVel = vel.xyz - texture2D(diffuseMap, uv).xyz;',\n\t\t\t\t'       vec3 ndist = normalize(dist);',\n\t\t\t\t'   \tforce += (- k * (length(dist) - restLengthX) - d * dot(relVel, ndist)) * ndist;',\n\t\t\t\t'\t}',\n\t\n\t\t\t\t// -x\n\t\t\t\t'   if(floor(gl_FragCoord.x) > minX){',\n\t\t\t\t'       vec2 uv = vUv + vec2(-invSizeX, 0);',\n\t\t\t\t'   \tvec3 dist = pos.xyz - texture2D(posMap, uv).xyz;',\n\t\t\t\t'   \tvec3 relVel = vel.xyz - texture2D(diffuseMap, uv).xyz;',\n\t\t\t\t'       vec3 ndist = normalize(dist);',\n\t\t\t\t'   \tforce += (- k * (length(dist) - restLengthX) - d * dot(relVel, ndist)) * ndist;',\n\t\t\t\t'   }',\n\t\n\t\t\t\t// +2*x - bending\n\t\t\t\t'\tif(floor(gl_FragCoord.x) < sizeX - 2.0){',\n\t\t\t\t'       vec2 uv = vUv + vec2(invSizeX * 2.0, 0);',\n\t\t\t\t'  \t\tvec3 dist = p - texture2D(posMap, uv).xyz;',\n\t\t\t\t'   \tvec3 relVel = v - texture2D(diffuseMap, uv).xyz;',\n\t\t\t\t'       vec3 ndist = normalize(dist);',\n\t\t\t\t'   \tforce += (- bendStiffness * (length(dist) - restLengthX * 2.0) - bendDamping * dot(relVel, ndist)) * ndist;',\n\t\t\t\t'\t}',\n\t\n\t\t\t\t// -2*x - bending\n\t\t\t\t'   if(floor(gl_FragCoord.x) > minX + 1.0){',\n\t\t\t\t'       vec2 uv = vUv + vec2(-invSizeX*2.0, 0);',\n\t\t\t\t'   \tvec3 dist = pos.xyz - texture2D(posMap, uv).xyz;',\n\t\t\t\t'   \tvec3 relVel = vel.xyz - texture2D(diffuseMap, uv).xyz;',\n\t\t\t\t'       vec3 ndist = normalize(dist);',\n\t\t\t\t'   \tforce += (- bendStiffness * (length(dist) - restLengthX*2.0) - bendDamping * dot(relVel, ndist)) * ndist;',\n\t\t\t\t'   }',\n\t\t\t\t\n\t\t\t\t// -2*y - bending - TODO\n\t\t\t\t/*\n\t\t\t\t'   if(floor(gl_FragCoord.y) > minY + 1.0){',\n\t\t\t\t'       vec2 uv = vUv + vec2(0, -invSizeY * 2.0);',\n\t\t\t\t'   \tvec3 dist = p - texture2D(posMap, uv).xyz;',\n\t\t\t\t'   \tvec3 relVel = v - texture2D(diffuseMap, uv).xyz;',\n\t\t\t\t'       vec3 ndist = normalize(dist);',\n\t\t\t\t'   \tforce += (- bendStiffness * (length(dist) - restLengthY * 2.0) - bendDamping * dot(relVel, ndist)) * ndist;',\n\t\t\t\t'\t}',\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\t// +2*y - bending - TODO\n\t\t\t\t/*\n\t\t\t\t'   if(floor(gl_FragCoord.y) > minY + 1.0){',\n\t\t\t\t'       vec2 uv = vUv + vec2(0, -invSizeY * 2.0);',\n\t\t\t\t'   \tvec3 dist = p - texture2D(posMap, uv).xyz;',\n\t\t\t\t'   \tvec3 relVel = v - texture2D(diffuseMap, uv).xyz;',\n\t\t\t\t'       vec3 ndist = normalize(dist);',\n\t\t\t\t'   \tforce += (- bendStiffness * (length(dist) - restLengthY * 2.0) - bendDamping * dot(relVel, ndist)) * ndist;',\n\t\t\t\t'\t}',\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\t// +xy\n\t\t\t\t'   if(floor(gl_FragCoord.x) < maxX && floor(gl_FragCoord.y) < maxY){',\n\t\t\t\t'       vec2 uv = vUv + vec2(invSizeX, invSizeX);',\n\t\t\t\t'   \tvec3 dist = pos.xyz - texture2D(posMap, uv).xyz;',\n\t\t\t\t'   \tvec3 relVel = vel.xyz - texture2D(diffuseMap, uv).xyz;',\n\t\t\t\t'       vec3 ndist = normalize(dist);',\n\t\t\t\t'   \tforce += (- k * (length(dist) - restLen2) - d * dot(relVel, ndist)) * ndist;',\n\t\t\t\t'   }',\n\t\n\t\t\t\t// -xy\n\t\t\t\t'   if(floor(gl_FragCoord.x) > minX && floor(gl_FragCoord.y) > minY){',\n\t\t\t\t'       vec2 uv = vUv + vec2(-invSizeX, -invSizeX);',\n\t\t\t\t'   \tvec3 dist = pos.xyz - texture2D(posMap, uv).xyz;',\n\t\t\t\t'   \tvec3 relVel = vel.xyz - texture2D(diffuseMap, uv).xyz;',\n\t\t\t\t'       vec3 ndist = normalize(dist);',\n\t\t\t\t'   \tforce += (- k * (length(dist) - restLen2) - d * dot(relVel, ndist)) * ndist;',\n\t\t\t\t'   }',\n\t\n\t\t\t\t// +x -y\n\t\t\t\t'   if(floor(gl_FragCoord.x) < maxX && floor(gl_FragCoord.y) > minY){',\n\t\t\t\t'       vec2 uv = vUv + vec2(invSizeX, -invSizeX);',\n\t\t\t\t'   \tvec3 dist = pos.xyz - texture2D(posMap, uv).xyz;',\n\t\t\t\t'   \tvec3 relVel = vel.xyz - texture2D(diffuseMap, uv).xyz;',\n\t\t\t\t'       vec3 ndist = normalize(dist);',\n\t\t\t\t'   \tforce += (- k * (length(dist) - restLen2) - d * dot(relVel, ndist)) * ndist;',\n\t\t\t\t'   }',\n\t\n\t\t\t\t// -x +y\n\t\t\t\t'   if(floor(gl_FragCoord.x) > minX && floor(gl_FragCoord.y) < maxY){',\n\t\t\t\t'       vec2 uv = vUv + vec2(-invSizeX, invSizeX);',\n\t\t\t\t'   \tvec3 dist = pos.xyz - texture2D(posMap, uv).xyz;',\n\t\t\t\t'   \tvec3 relVel = vel.xyz - texture2D(diffuseMap, uv).xyz;',\n\t\t\t\t'       vec3 ndist = normalize(dist);',\n\t\t\t\t'   \tforce += (- k * (length(dist) - restLen2) - d * dot(relVel, ndist)) * ndist;',\n\t\t\t\t'   }',\n\t\t\t\t\n\t\t\t\t// Spatial damping\n\t\t\t\t'   force -= spatialDamping * vel.xyz;',\n\t\n\t\t\t\t'   vec4 newVel = vec4(vel.xyz + invMass * force * dt, invMass);',\n\t\n\t\t\t\t// '   newVel.xyz = newVel.xyz * pow(1.0 - damping, dt);',\n\t\n\t\t\t\t'   gl_FragColor = newVel;',\n\t\t\t\t'}'\n\t\t\t].join('\\n')\n\t\t};\n\t\n\t\tvar particleUpdateShader = {\n\t\t\tattributes: {\n\t\t\t\tvertexPosition: MeshData.POSITION,\n\t\t\t\tvertexUV0: MeshData.TEXCOORD0\n\t\t\t},\n\t\t\tuniforms: {\n\t\t\t\tviewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,\n\t\t\t\tworldMatrix: Shader.WORLD_MATRIX,\n\t\t\t\tdiffuseMap: Shader.DIFFUSE_MAP,\n\t\t\t\tvelocityMap: 'VELOCITY_MAP',\n\t\t\t\tstartMap: 'START_MAP',\n\t\t\t\tdt: 1 / args.stepFrequency,\n\t\t\t\tradius: 0.8,\n\t\t\t\tsetInvMass: -1\n\t\t\t},\n\t\t\tvshader: [\n\t\t\t\t'precision highp float;',\n\t\t\t\t'attribute vec3 vertexPosition;',\n\t\t\t\t'attribute vec2 vertexUV0;',\n\t\n\t\t\t\t'uniform mat4 viewProjectionMatrix;',\n\t\t\t\t'uniform mat4 worldMatrix;',\n\t\n\t\t\t\t'varying vec2 vUv;',\n\t\n\t\t\t\t'void main() {',\n\t\t\t\t'   vUv = vertexUV0;',\n\t\t\t\t'   gl_Position = viewProjectionMatrix * worldMatrix * vec4( vertexPosition, 1.0 );',\n\t\t\t\t'}'\n\t\t\t].join('\\n'),\n\t\t\tfshader: [\n\t\t\t\t'precision highp float;',\n\t\t\t\t'uniform sampler2D diffuseMap;',\n\t\t\t\t'uniform sampler2D velocityMap;',\n\t\t\t\t'uniform sampler2D startMap;',\n\t\t\t\t'uniform vec3 forcePos;',\n\t\n\t\t\t\t'uniform float setInvMass;',\n\t\t\t\t'uniform float dt;',\n\t\t\t\t'uniform float radius;',\n\t\t\t\t'varying vec2 vUv;',\n\t\n\t\t\t\t'void main() {',\n\t\t\t\t'   vec4 pos = texture2D(diffuseMap, vUv);',\n\t\t\t\t'   vec4 vel = texture2D(velocityMap, vUv);',\n\t\t\t\t'   vec3 newpos = pos.xyz + vel.xyz * dt;',\n\t\t\t\t'   float invMass = pos.w;',\n\t\t\t\t\n\t\t\t\t'   if(setInvMass >= 0.0){',\n\t\t\t\t'       invMass = 1.0;',\n\t\t\t\t'       pos.w = 1.0;',\n\t\t\t\t'   }',\n\t\t\t\t\n\t\t\t\t'   if(invMass <= 0.0){',\n\t\t\t\t'       gl_FragColor = pos;', // Static\n\t\t\t\t'   } else {',\n\t\t\t\t'       gl_FragColor = vec4(newpos, pos.w);',\n\t\t\t\t'   }',\n\t\t\t\t'}'\n\t\t\t].join('\\n')\n\t\t};\n\t\n\t\t// Test uber!\n\t\tvar newParticleShader = {\n\t\t\tprocessors: [\n\t\t\t\tShaderBuilder.uber.processor,\n\t\t\t\tShaderBuilder.light.processor,\n\t\t\t\tShaderBuilder.animation.processor,\n\t\t\t\tfunction(shader, shaderInfo){\n\t\t\t\t\tshader.defines.NORMAL = true;\n\t\t\t\t\tshader.defines.TANGENT = true;\n\t\t\t\t}\n\t\t\t],\n\t\t\tdefines: {\n\t\t\t\tNORMAL: true,\n\t\t\t\tTANGENT: true\n\t\t\t},\n\t\t\tattributes: {\n\t\t\t\tvertexPosition: MeshData.POSITION,\n\t\t\t\tvertexTangent: MeshData.TANGENT,\n\t\t\t\tvertexColor: MeshData.COLOR,\n\t\t\t\tvertexUV0: MeshData.TEXCOORD0,\n\t\t\t\tvertexUV1: MeshData.TEXCOORD1,\n\t\t\t\tvertexJointIDs: MeshData.JOINTIDS,\n\t\t\t\tvertexWeights: MeshData.WEIGHTS\n\t\t\t},\n\t\t\tuniforms: {\n\t\t\t\tviewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,\n\t\t\t\tworldMatrix: Shader.WORLD_MATRIX,\n\t\t\t\tnormalMatrix: Shader.NORMAL_MATRIX,\n\t\t\t\tcameraPosition: Shader.CAMERA,\n\t\t\t\tdiffuseMap : Shader.DIFFUSE_MAP,\n\t\t\t\toffsetRepeat : [0,0,1,1],\n\t\t\t\tnormalMap : Shader.NORMAL_MAP,\n\t\t\t\tnormalMultiplier: 1.0,\n\t\t\t\tspecularMap : Shader.SPECULAR_MAP,\n\t\t\t\temissiveMap : Shader.EMISSIVE_MAP,\n\t\t\t\taoMap : Shader.AO_MAP,\n\t\t\t\tlightMap : Shader.LIGHT_MAP,\n\t\t\t\tenvironmentCube : 'ENVIRONMENT_CUBE',\n\t\t\t\tenvironmentSphere : 'ENVIRONMENT_SPHERE',\n\t\t\t\treflectionMap : 'REFLECTION_MAP',\n\t\t\t\ttransparencyMap : 'TRANSPARENCY_MAP',\n\t\t\t\topacity: 1.0,\n\t\t\t\treflectivity: 0.0,\n\t\t\t\trefractivity: 0.0,\n\t\t\t\tetaRatio: -0.5,\n\t\t\t\tfresnel: 0.0,\n\t\t\t\tdiscardThreshold: -0.01,\n\t\t\t\tfogSettings: [0, 10000],\n\t\t\t\tfogColor: [1, 1, 1],\n\t\t\t\tshadowDarkness: 0.5,\n\t\t\t\tvertexColorAmount: 1.0,\n\t\t\t\tlodBias: 0.0,\n\t\t\t\twrapSettings: [0.5, 0.0],\n\t\t\t\t\n\t\t\t\t// Particle stuff\n\t\t\t\tparticleMap: 'PARTICLE_MAP',\n\t\t\t\tpositionMap: 'POS_MAP',\n\t\t\t\tinvSizeX: 1 / ctx.sizeX,\n\t\t\t\tinvSizeY: 1 / ctx.sizeY,\n\t\t\t\tsizeX: ctx.sizeX,\n\t\t\t\tsizeY: ctx.sizeY\n\t\t\t},\n\t\t\tbuilder: function (shader, shaderInfo) {\n\t\t\t\tShaderBuilder.light.builder(shader, shaderInfo);\n\t\t\t},\n\t\t\tvshader: function () {\n\t\t\t\treturn [\n\t\t\t\t\n\t\t\t\t//We compute the normal dynamically\n\t\t\t\t/*\n\t\t\t\t'#ifdef NORMAL',\n\t\t\t\t\t'attribute vec3 vertexNormal;',\n\t\t\t\t'#endif',\n\t\t\t\t*/\n\t\t\t\t/*\n\t\t\t\t'#ifdef TANGENT',\n\t\t\t\t\t'attribute vec4 vertexTangent;',\n\t\t\t\t'#endif',\n\t\t\t\t*/\n\t\t\t\t'#ifdef COLOR',\n\t\t\t\t\t'attribute vec4 vertexColor;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef TEXCOORD0',\n\t\t\t\t\t'attribute vec2 vertexUV0;',\n\t\t\t\t\t'uniform vec4 offsetRepeat;',\n\t\t\t\t\t'varying vec2 texCoord0;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef TEXCOORD1',\n\t\t\t\t\t'attribute vec2 vertexUV1;',\n\t\t\t\t\t'varying vec2 texCoord1;',\n\t\t\t\t'#endif',\n\t\n\t\t\t\t'uniform mat4 viewProjectionMatrix;',\n\t\t\t\t'uniform mat4 worldMatrix;',\n\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\t\n\t\t\t\t'varying vec3 vWorldPos;',\n\t\t\t\t'varying vec3 viewPosition;',\n\t\t\t\t'#ifdef NORMAL',\n\t\t\t\t'varying vec3 vertexNormal;',\n\t\t\t\t'varying vec3 normal;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef TANGENT',\n\t\t\t\t'varying vec3 binormal;',\n\t\t\t\t'varying vec3 tangent;',\n\t\t\t\t'varying vec4 vertexTangent;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef COLOR',\n\t\t\t\t'varying vec4 color;',\n\t\t\t\t'#endif',\n\t\t\t\t\n\t\t\t\t// Particle stuff\n\t\t\t\t'uniform float invSizeY;',\n\t\t\t\t'uniform float invSizeX;',\n\t\t\t\t'uniform float sizeY;',\n\t\t\t\t'uniform float sizeX;',\n\t\t\t\t'uniform sampler2D diffuseMap;',\n\t\t\t\t'uniform sampler2D positionMap;',\n\t\n\t\t\t\tShaderBuilder.light.prevertex,\n\t\n\t\t\t\tShaderBuilder.animation.prevertex,\n\t\n\t\t\t\t'void main(void) {',\n\t\t\t\t\n\t\t\t\t\t// Start particle stuff\n\t\t\t\t\t'float a = ((sizeX-1.0) / (sizeX));',\n\t\t\t\t\t'vec2 offset = vec2(0.5 * invSizeX);',\n\t\t\t\t\t\n\t\t\t\t\t// TODO: could for sure avoid the if/else statements here\n\t\t\t\t\t'vec3 vertexPosition = texture2D(positionMap,  (vertexUV0 + offset                      ) * a).xyz;',\n\t\t\t\t\t'vec3 vertexPosition1 = texture2D(positionMap, (vertexUV0 + offset + vec2(invSizeX, 0.0)) * a).xyz;',\n\t\t\t\t\t'vec3 vertexPosition2 = texture2D(positionMap, (vertexUV0 + offset + vec2(0.0, invSizeY)) * a).xyz;',\n\t\t\t\t\t\n\t\t\t\t\t'if(vertexUV0.x > 0.5 && vertexUV0.y > 0.5){',\n\t\t\t\t\t\t'vertexPosition1 = texture2D(positionMap, (vertexUV0 + offset - vec2(invSizeX, 0.0)) * a).xyz;',\n\t\t\t\t\t\t'vertexPosition2 = texture2D(positionMap, (vertexUV0 + offset - vec2(0.0, invSizeY)) * a).xyz;',\n\t\t\t\t\t'} else if(vertexUV0.x > 0.5){',\n\t\t\t\t\t\t'vertexPosition2 = texture2D(positionMap, (vertexUV0 + offset - vec2(invSizeX, 0.0)) * a).xyz;',\n\t\t\t\t\t\t'vertexPosition1 = texture2D(positionMap, (vertexUV0 + offset + vec2(0.0, invSizeY)) * a).xyz;',\n\t\t\t\t\t'} else if(vertexUV0.y > 0.5){',\n\t\t\t\t\t\t'vertexPosition2 = texture2D(positionMap, (vertexUV0 + offset + vec2(invSizeX, 0.0)) * a).xyz;',\n\t\t\t\t\t\t'vertexPosition1 = texture2D(positionMap, (vertexUV0 + offset - vec2(0.0, invSizeY)) * a).xyz;',\n\t\t\t\t\t'}',\n\t\t\t\t\t\n\t\t\t\t\t'#ifdef NORMAL',\n\t\t\t\t\t'    vertexNormal = -cross(vertexPosition2 - vertexPosition, vertexPosition1 - vertexPosition);',\n\t\t\t\t \t'#endif',\n\t\t\t\t \t'#ifdef TANGENT',\n\t\t\t\t\t'    vertexNormal = -cross(vertexPosition2 - vertexPosition, vertexPosition1 - vertexPosition);',\n\t\t\t\t\t'    tangent = normalize(vertexPosition2 - vertexPosition);',\n\t\t\t\t\t'    binormal = cross(tangent, vertexNormal);',\n\t\t\t\t\t'    vertexTangent = vec4(tangent.xyz, 1.0);',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t//'normal = normalize((viewProjectionMatrix * vec4(normal, 0.0)).xyz);',\n\t\t\t\t\t//'vec3 vertexNormal = normal.xyz;',\n\t\t\t\t\t// End particle stuff\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t'mat4 wMatrix = worldMatrix;',\n\t\t\t\t\t'#ifdef NORMAL',\n\t\t\t\t\t\t'mat3 nMatrix = normalMatrix;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\tShaderBuilder.animation.vertex,\n\t\t\t\t\t'vec4 worldPos = wMatrix * vec4(vertexPosition, 1.0);',\n\t\t\t\t\t'vWorldPos = worldPos.xyz;',\n\t\t\t\t\t'gl_Position = viewProjectionMatrix * worldPos;',\n\t\n\t\t\t\t\t'viewPosition = cameraPosition - worldPos.xyz;',\n\t\n\t\n\t\n\t\t\t\t\t'#ifdef NORMAL',\n\t\t\t\t\t'\tnormal = normalize((nMatrix * vertexNormal).xyz);',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t'#ifdef TANGENT',\n\t\t\t\t\t'\ttangent = normalize((nMatrix * vertexTangent.xyz).xyz);',\n\t\t\t\t\t'\tbinormal = cross(normal, tangent) * vec3(vertexTangent.w);',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t'#ifdef COLOR',\n\t\t\t\t\t'\tcolor = vertexColor;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t'#ifdef TEXCOORD0',\n\t\t\t\t\t'\ttexCoord0 = vertexUV0 * offsetRepeat.zw + offsetRepeat.xy;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t'#ifdef TEXCOORD1',\n\t\t\t\t\t'\ttexCoord1 = vertexUV1;',\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\tShaderBuilder.light.vertex,\n\t\t\t\t'}'\n\t\t\t].join('\\n');\n\t\t\t},\n\t\t\tfshader: function () {\n\t\t\t\treturn [\n\t\t\t\t'uniform float lodBias;',\n\t\t\t\t'#ifdef DIFFUSE_MAP',\n\t\t\t\t\t'uniform sampler2D diffuseMap;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef NORMAL_MAP',\n\t\t\t\t\t'uniform sampler2D normalMap;',\n\t\t\t\t\t'uniform float normalMultiplier;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef SPECULAR_MAP',\n\t\t\t\t\t'uniform sampler2D specularMap;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef EMISSIVE_MAP',\n\t\t\t\t\t'uniform sampler2D emissiveMap;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef AO_MAP',\n\t\t\t\t\t'uniform sampler2D aoMap;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef LIGHT_MAP',\n\t\t\t\t\t'uniform sampler2D lightMap;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef TRANSPARENCY_MAP',\n\t\t\t\t\t'uniform sampler2D transparencyMap;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef REFLECTIVE',\n\t\t\t\t\t'#ifdef ENVIRONMENT_CUBE',\n\t\t\t\t\t\t'uniform samplerCube environmentCube;',\n\t\t\t\t\t'#elif defined(ENVIRONMENT_SPHERE)',\n\t\t\t\t\t\t'uniform sampler2D environmentSphere;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t'uniform vec4 clearColor;',\n\t\t\t\t\t'uniform float reflectivity;',\n\t\t\t\t\t'uniform float fresnel;',\n\t\t\t\t\t'uniform float refractivity;',\n\t\t\t\t\t'uniform float etaRatio;',\n\t\t\t\t\t'#ifdef REFLECTION_MAP',\n\t\t\t\t\t\t'uniform sampler2D reflectionMap;',\n\t\t\t\t\t'#endif',\n\t\t\t\t'#endif',\n\t\n\t\t\t\t'uniform float opacity;',\n\t\t\t\t'#ifdef DISCARD',\n\t\t\t\t\t'uniform float discardThreshold;',\n\t\t\t\t'#endif',\n\t\n\t\t\t\t'#ifdef FOG',\n\t\t\t\t\t'uniform vec2 fogSettings;',\n\t\t\t\t\t'uniform vec3 fogColor;',\n\t\t\t\t'#endif',\n\t\n\t\t\t\t'varying vec3 vWorldPos;',\n\t\t\t\t'varying vec3 viewPosition;',\n\t\t\t\t'#ifdef NORMAL',\n\t\t\t\t\t'varying vec3 normal;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef TANGENT',\n\t\t\t\t\t'varying vec3 binormal;',\n\t\t\t\t\t'varying vec3 tangent;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef COLOR',\n\t\t\t\t\t'varying vec4 color;',\n\t\t\t\t\t'uniform float vertexColorAmount;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef TEXCOORD0',\n\t\t\t\t\t'varying vec2 texCoord0;',\n\t\t\t\t'#endif',\n\t\t\t\t'#ifdef TEXCOORD1',\n\t\t\t\t\t'varying vec2 texCoord1;',\n\t\t\t\t'#endif',\n\t\n\t\t\t\tShaderBuilder.light.prefragment,\n\t\t\t\t\n\t\t\t\t// Particle stuff\n\t\t\t\t'uniform sampler2D particleMap;',\n\t\t\t\t// End particle stuff\n\t\n\t\t\t\t'void main(void)',\n\t\t\t\t'{',\n\t\t\t\t\t'vec4 final_color = vec4(1.0);',\n\t\n\t\t\t\t\t'#if defined(DIFFUSE_MAP) && defined(TEXCOORD0)',\n\t\t\t\t\t\t//'final_color *= texture2D(diffuseMap, texCoord0, lodBias);',\n\t\t\t\t\t\t//'final_color *= texture2D(diffuseMap, vec2(-texCoord0.x, texCoord0.y), lodBias);',\n\t\t\t\t\t\t'final_color *= texture2D(diffuseMap, texCoord0, lodBias);',\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef COLOR',\n\t\t\t\t\t\t'final_color *= mix(vec4(1.0), color, vertexColorAmount);',\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#if defined(TRANSPARENCY_MAP) && defined(TEXCOORD0)',\n\t\t\t\t\t\t'final_color.a = texture2D(transparencyMap, texCoord0).a;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t'final_color.a *= opacity;',\n\t\n\t\t\t\t\t'#ifdef DISCARD',\n\t\t\t\t\t\t'if (final_color.a < discardThreshold) discard;',\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef AO_MAP',\n\t\t\t\t\t\t'#ifdef TEXCOORD1',\n\t\t\t\t\t\t\t'final_color.rgb *= texture2D(aoMap, texCoord1).rgb;',\n\t\t\t\t\t\t'#elif defined(TEXCOORD0)',\n\t\t\t\t\t\t\t'final_color.rgb *= texture2D(aoMap, texCoord0).rgb;',\n\t\t\t\t\t\t'#endif',\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef LIGHT_MAP',\n\t\t\t\t\t\t'#ifdef TEXCOORD1',\n\t\t\t\t\t\t\t'final_color.rgb *= texture2D(lightMap, texCoord1).rgb * 2.0 - 0.5;',\n\t\t\t\t\t\t'#elif defined(TEXCOORD0)',\n\t\t\t\t\t\t\t'final_color.rgb *= texture2D(lightMap, texCoord0).rgb * 2.0 - 0.5;',\n\t\t\t\t\t\t'#endif',\n\t\t\t\t\t'#else',\n\t\t\t\t\t\t'vec3 N = vec3(0.0, 1.0, 0.0);',\n\t\t\t\t\t\t'#if defined(NORMAL)', // Do nasty doublework for IE compliance\n\t\t\t\t\t\t\t'N = normalize(normal);',\n\t\t\t\t\t\t'#endif',\n\t\t\t\t\t\t'#if defined(TANGENT) && defined(NORMAL_MAP) && defined(TEXCOORD0)',\n\t\t\t\t\t\t\t'mat3 tangentToWorld = mat3(tangent, binormal, normal);',\n\t\t\t\t\t\t\t'vec3 tangentNormal = texture2D(normalMap, texCoord0, lodBias).xyz * vec3(2.0) - vec3(1.0);',\n\t\t\t\t\t\t\t'tangentNormal.xy *= normalMultiplier;',\n\t\t\t\t\t\t\t'vec3 worldNormal = (tangentToWorld * tangentNormal);',\n\t\t\t\t\t\t\t'N = normalize(worldNormal);',\n\t\t\t\t\t\t// '#elif defined(NORMAL)',\n\t\t\t\t\t\t\t// 'N = normalize(normal);',\n\t\t\t\t\t\t// '#endif',\n\t\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t\tShaderBuilder.light.fragment,\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef REFLECTIVE',\n\t\t\t\t\t\t'if (refractivity > 0.0) {',\n\t\t\t\t\t\t\t'vec3 refractionVector = refract(normalize(viewPosition), N, etaRatio);',\n\t\t\t\t\t\t\t// 'refractionVector.yz = -refractionVector.yz;',\n\t\t\t\t\t\t\t'refractionVector.x = -refractionVector.x;',\n\t\t\t\t\t\t\t'vec4 environment = vec4(0.0);',\n\t\t\t\t\t\t\t'#ifdef ENVIRONMENT_CUBE',\n\t\t\t\t\t\t\t\t'environment = textureCube(environmentCube, refractionVector);',\n\t\t\t\t\t\t\t'#elif defined(ENVIRONMENT_SPHERE)',\n\t\t\t\t\t\t\t\t'refractionVector = -refractionVector;',\n\t\t\t\t\t\t\t\t'float m = 4.0 * sqrt(refractionVector.x*refractionVector.x + refractionVector.y*refractionVector.y + (refractionVector.z+1.0)*(refractionVector.z+1.0));',\n\t\t\t\t\t\t\t\t'environment = texture2D(environmentSphere, (refractionVector.xy / m) + 0.5);',\n\t\t\t\t\t\t\t'#endif',\n\t\t\t\t\t\t\t'environment.rgb = mix(clearColor.rgb, environment.rgb, environment.a);',\n\t\n\t\t\t\t\t\t\t'final_color.rgb = mix(final_color.rgb, environment.rgb, refractivity);',\n\t\t\t\t\t\t'}',\n\t\n\t\t\t\t\t\t'if (reflectivity > 0.0) {',\n\t\t\t\t\t\t\t'vec3 reflectionVector = reflect(viewPosition, N);',\n\t\t\t\t\t\t\t'reflectionVector.yz = -reflectionVector.yz;',\n\t\n\t\t\t\t\t\t\t'vec4 environment = vec4(0.0);',\n\t\t\t\t\t\t\t'#ifdef ENVIRONMENT_CUBE',\n\t\t\t\t\t\t\t\t'environment = textureCube(environmentCube, reflectionVector);',\n\t\t\t\t\t\t\t'#elif defined(ENVIRONMENT_SPHERE)',\n\t\t\t\t\t\t\t\t'reflectionVector = -reflectionVector;',\n\t\t\t\t\t\t\t\t'float m = 4.0 * sqrt(reflectionVector.x*reflectionVector.x + reflectionVector.y*reflectionVector.y + (reflectionVector.z+1.0)*(reflectionVector.z+1.0));',\n\t\t\t\t\t\t\t\t'environment = texture2D(environmentSphere, (reflectionVector.xy / m) + 0.5);',\n\t\t\t\t\t\t\t'#endif',\n\t\t\t\t\t\t\t'environment.rgb = mix(clearColor.rgb, environment.rgb, environment.a);',\n\t\n\t\t\t\t\t\t\t'float reflectionAmount = reflectivity;',\n\t\t\t\t\t\t\t'#if defined(REFLECTION_MAP) && defined(TEXCOORD0)',\n\t\t\t\t\t\t\t\t'reflectionAmount *= texture2D(reflectionMap, texCoord0).r;',\n\t\t\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t\t\t'float fresnelVal = pow(1.0 - abs(dot(normalize(viewPosition), N)), fresnel * 4.0);',\n\t\t\t\t\t\t\t'reflectionAmount *= fresnelVal;',\n\t\n\t\t\t\t\t\t\t'#if REFLECTION_TYPE == 0',\n\t\t\t\t\t\t\t\t'final_color.rgb = mix(final_color.rgb, environment.rgb, reflectionAmount);',\n\t\t\t\t\t\t\t'#elif REFLECTION_TYPE == 1',\n\t\t\t\t\t\t\t\t'final_color.rgb += environment.rgb * reflectionAmount;',\n\t\t\t\t\t\t\t'#endif',\n\t\t\t\t\t\t'}',\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifndef LIGHT_MAP',\n\t\t\t\t\t\t'final_color.rgb += totalSpecular;',\n\t\t\t\t\t\t'final_color.a += min(length(totalSpecular), 1.0);',\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef FOG',\n\t\t\t\t\t\t'float d = pow(smoothstep(fogSettings.x, fogSettings.y, length(viewPosition)), 1.0);',\n\t\t\t\t\t\t'final_color.rgb = mix(final_color.rgb, fogColor, d);',\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'gl_FragColor = final_color;',\n\t\t\t\t'}'\n\t\t\t].join('\\n');\n\t\t\t}\n\t\t};\n\t\n\t\tinit();\n\t\n\t\tif (args.useDeviceGravity && window.DeviceMotionEvent) {\n\t\t\tctx.listeners.devicemotion = function (eventData) {\n\t\t\t\tg = eventData.accelerationIncludingGravity;\n\t\t\t\tvar gs = args.deviceGravityScale;\n\t\t\t\tif(g.x !== null){\n\t\t\t\t\targs.gravity[0] = g.x * gs;\n\t\t\t\t\targs.gravity[1] = g.y * gs;\n\t\t\t\t\targs.gravity[2] = g.z * gs;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\t\n\t} else {\n\t\t\n\t\t// Javascript setup()\n\t\tgoo.Surface = function(verts, vertsPerLine, verticallyClosed) {\n\t\t\tthis.verts = verts;\n\t\t\tthis.vertsPerLine = vertsPerLine || 2;\n\t\t\tthis.verticallyClosed = !!verticallyClosed;\n\t\n\t\t\tvar attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);\n\t\n\t\t\tvar nVerts = this.verts.length / 3;\n\t\t\tvar nLines = nVerts / this.vertsPerLine;\n\t\t\tMeshData.call(this, attributeMap, nVerts, (nLines - 1) * (this.vertsPerLine - 1) * 6);\n\t\n\t\t\tthis.rebuild();\n\t\t}\n\t\n\t\tgoo.Surface.prototype = Object.create(MeshData.prototype);\n\t\tgoo.Surface.prototype.constructor = goo.Surface;\n\t\n\t\tgoo.Surface.prototype.rebuild = function () {\n\t\t\tthis.getAttributeBuffer(MeshData.POSITION).set(this.verts);\n\t\n\t\t\tvar indices = [];\n\t\n\t\t\tvar norms = [];\n\t\t\tvar normals = [];\n\t\n\t\t\tvar nVerts = this.verts.length / 3;\n\t\t\tvar nLines = nVerts / this.vertsPerLine;\n\t\n\t\t\tfor (var i = 0; i < nLines - 1; i++) {\n\t\t\t\tfor (var j = 0; j < this.vertsPerLine - 1; j++) {\n\t\t\t\t\tvar upLeft = (i + 0) * this.vertsPerLine + (j + 0);\n\t\t\t\t\tvar downLeft = (i + 1) * this.vertsPerLine + (j + 0);\n\t\t\t\t\tvar downRight = (i + 1) * this.vertsPerLine + (j + 1);\n\t\t\t\t\tvar upRight = (i + 0) * this.vertsPerLine + (j + 1);\n\t\n\t\t\t\t\tindices.push(upLeft, downLeft, upRight, upRight, downLeft, downRight);\n\t\n\t\t\t\t\tnormals = MathUtils.getTriangleNormal(\n\t\t\t\t\t\tthis.verts[upLeft * 3 + 0],\n\t\t\t\t\t\tthis.verts[upLeft * 3 + 1],\n\t\t\t\t\t\tthis.verts[upLeft * 3 + 2],\n\t\n\t\t\t\t\t\tthis.verts[downLeft * 3 + 0],\n\t\t\t\t\t\tthis.verts[downLeft * 3 + 1],\n\t\t\t\t\t\tthis.verts[downLeft * 3 + 2],\n\t\n\t\t\t\t\t\tthis.verts[upRight * 3 + 0],\n\t\t\t\t\t\tthis.verts[upRight * 3 + 1],\n\t\t\t\t\t\tthis.verts[upRight * 3 + 2]);\n\t\n\t\t\t\t\tnorms.push(normals[0], normals[1], normals[2]);\n\t\t\t\t}\n\t\n\t\t\t\tif(this.verticallyClosed) {\n\t\t\t\t\tvar upLeft = (i + 0) * this.vertsPerLine + (0 + 0);\n\t\t\t\t\tvar downLeft = (i + 1) * this.vertsPerLine + (0 + 0);\n\t\t\t\t\tvar upRight = (i + 0) * this.vertsPerLine + (0 + 1);\n\t\n\t\t\t\t\tnormals = MathUtils.getTriangleNormal(\n\t\t\t\t\t\tthis.verts[upLeft * 3 + 0],\n\t\t\t\t\t\tthis.verts[upLeft * 3 + 1],\n\t\t\t\t\t\tthis.verts[upLeft * 3 + 2],\n\t\n\t\t\t\t\t\tthis.verts[downLeft * 3 + 0],\n\t\t\t\t\t\tthis.verts[downLeft * 3 + 1],\n\t\t\t\t\t\tthis.verts[downLeft * 3 + 2],\n\t\n\t\t\t\t\t\tthis.verts[upRight * 3 + 0],\n\t\t\t\t\t\tthis.verts[upRight * 3 + 1],\n\t\t\t\t\t\tthis.verts[upRight * 3 + 2]);\n\t\n\t\t\t\t\tnorms.push(normals[0], normals[1], normals[2]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnorms.push(normals[0], normals[1], normals[2]);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\ti--;\n\t\t\tfor (var j = 0; j < this.vertsPerLine - 1; j++) {\n\t\t\t\tvar upLeft = (i + 0) * this.vertsPerLine + (j + 0);\n\t\t\t\tvar downLeft = (i + 1) * this.vertsPerLine + (j + 0);\n\t\t\t\tvar upRight = (i + 0) * this.vertsPerLine + (j + 1);\n\t\n\t\t\t\tnormals = MathUtils.getTriangleNormal(\n\t\t\t\t\tthis.verts[upLeft * 3 + 0],\n\t\t\t\t\tthis.verts[upLeft * 3 + 1],\n\t\t\t\t\tthis.verts[upLeft * 3 + 2],\n\t\n\t\t\t\t\tthis.verts[downLeft * 3 + 0],\n\t\t\t\t\tthis.verts[downLeft * 3 + 1],\n\t\t\t\t\tthis.verts[downLeft * 3 + 2],\n\t\n\t\t\t\t\tthis.verts[upRight * 3 + 0],\n\t\t\t\t\tthis.verts[upRight * 3 + 1],\n\t\t\t\t\tthis.verts[upRight * 3 + 2]);\n\t\n\t\t\t\tnorms.push(normals[0], normals[1], normals[2]);\n\t\t\t}\n\t\n\t\t\tnorms.push(normals[0], normals[1], normals[2]);\n\t\n\t\t\tthis.getAttributeBuffer(MeshData.NORMAL).set(norms);\n\t\t\tthis.getIndexBuffer().set(indices);\n\t\n\t\t\t// compute texture coordinates\n\t\t\tvar tex = [];\n\t\t\tvar bounds = getBounds(this.verts);\n\t\t\tvar extentX = bounds.maxX - bounds.minX;\n\t\t\tvar extentY = bounds.maxY - bounds.minY;\n\t\n\t\t\tfor (var i = 0; i < this.verts.length; i += 3) {\n\t\t\t\tvar x = -(this.verts[i + 0] - bounds.minX) / extentX;\n\t\t\t\tvar y = (this.verts[i + 2] - bounds.minY) / extentY;\n\t\t\t\ttex.push(x, y);\n\t\t\t}\n\t\n\t\t\tthis.getAttributeBuffer(MeshData.TEXCOORD0).set(tex);\n\t\n\t\t\treturn this;\n\t\t};\n\t\n\t\tfunction getBounds(verts) {\n\t\t\tvar minX = verts[0];\n\t\t\tvar maxX = verts[0];\n\t\t\tvar minY = verts[1];\n\t\t\tvar maxY = verts[1];\n\t\n\t\t\tfor (var i = 3; i < verts.length; i += 3) {\n\t\t\t\tminX = minX < verts[i + 0] ? minX : verts[i + 0];\n\t\t\t\tmaxX = maxX > verts[i + 0] ? maxX : verts[i + 0];\n\t\t\t\tminY = minY < verts[i + 2] ? minY : verts[i + 2];\n\t\t\t\tmaxY = maxY > verts[i + 2] ? maxY : verts[i + 2];\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tminX: minX,\n\t\t\t\tmaxX: maxX,\n\t\t\t\tminY: minY,\n\t\t\t\tmaxY: maxY\n\t\t\t};\n\t\t}\n\t\n\t\tgoo.Surface.createFromHeightMap = function (heightMap, xScale, yScale, zScale) {\n\t\t\txScale = xScale || 1;\n\t\t\tyScale = yScale || 1;\n\t        zScale = zScale || 1;\n\t\n\t\t\tvar verts = [];\n\t\t\tfor (var i = 0; i < heightMap.length; i++) {\n\t\t\t\tfor (var j = 0; j < heightMap[i].length; j++) {\n\t\t\t\t\tverts.push(i * xScale, heightMap[i][j]*yScale, j * zScale);\n\t\t\t\t}\n\t\t\t}\n\t\t\tverts.reverse();\n\t\n\t\t\treturn new goo.Surface(verts, heightMap[0].length);\n\t\t};\n\t\n\t\tvar velocityInfo;\n\t\tvar positionInfo;\n\t\tvar velocityTexture;\n\t\tvar positionTexture;\n\t\tvar particleUpdateMaterial;\n\t\tvar particleUpdateVelocityMaterial;\n\t\tvar renderable;\n\t\tvar positionTarget1;\n\t\tvar positionTarget2;\n\t\tvar velocityTarget1;\n\t\tvar velocityTarget2;\n\t\tvar cursorX = -0.5;\n\t\tvar cursorY = -0.5;\n\t\t\n\t\t// Compute size\n\t\tctx.sizeX = Math.pow(2, args.js_sizeX);\n\t\tctx.sizeY = Math.pow(2, args.js_sizeY);\n\t\n\t\tvar scale = ctx.entity.getScale();\n\t\tvar restLengthX = 2 * quad.xExtent * scale.x / (ctx.sizeX - 1);\n\t\tvar restLengthY = 2 * quad.yExtent * scale.y / (ctx.sizeY - 1);\n\t\t\n\t\tvar textureSettings = {\n\t\t\ttype: 'Float',\n\t\t\tminFilter: 'NearestNeighborNoMipMaps',\n\t\t\tmagFilter: 'NearestNeighbor',\n\t\t};\n\t\n\t\tvar createClothMesh = function (nx, ny) {\n\t\t\tvar m = [], meshDummyMatrix = [];\n\t\t\tfor (var i = 0; i < ny; i++) {\n\t\t\t\tmeshDummyMatrix.push([]);\n\t\t\t\tfor (var j = 0; j < nx; j++) {\n\t\t\t\t\tmeshDummyMatrix[i].push(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn goo.Surface.createFromHeightMap(meshDummyMatrix);\n\t\t}\n\t\t\n\t\tvar fillInfo = function (positionInfo, velocityInfo, massInfo, onlyStatic){\n\t\t\tvar worldPosition = new Vector3();\n\t\t\tfor (var x = 0; x < ctx.sizeX; x++) {\n\t\t\t\tfor (var y = 0; y < ctx.sizeY; y++) {\n\t\t\t\t\tvar i = y * ctx.sizeX + x;\n\t\t\t\t\t\n\t\t\t\t\tvar staticParticle = isStatic(args.js_attachmentMode, x, y, ctx, args.js_N);\n\t\t\t\t\t\n\t\t\t\t\tif(onlyStatic && !staticParticle){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar invMass = staticParticle ? 0 : 1;\n\t\n\t\t\t\t\tgetParticleInitialPosition(\n\t\t\t\t\t\tgoo,\n\t\t\t\t\t\tctx.entity,\n\t\t\t\t\t\tscale,\n\t\t\t\t\t\tx,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\tctx.sizeX, \n\t\t\t\t\t\tctx.sizeY,\n\t\t\t\t\t\trestLengthX,\n\t\t\t\t\t\trestLengthY,\n\t\t\t\t\t\targs.js_foldFactor,\n\t\t\t\t\t\tworldPosition\n\t\t\t\t\t);\n\t\n\t\t\t\t\t// position\n\t\t\t\t\tpositionInfo[i * 3 + 0] = worldPosition.x;\n\t\t\t\t\tpositionInfo[i * 3 + 1] = worldPosition.y;\n\t\t\t\t\tpositionInfo[i * 3 + 2] = worldPosition.z;\n\t\n\t\t\t\t\t// mass\n\t\t\t\t\tmassInfo[i] = invMass;\n\t\n\t\t\t\t\t// velocity\n\t\t\t\t\tvar m = staticParticle ? 0 : 1;\n\t\t\t\t\tvelocityInfo[i * 3 + 0] = (2 * rng.nextFloat() - 1) * args.js_velocityNoise[0] * m;\n\t\t\t\t\tvelocityInfo[i * 3 + 1] = (2 * rng.nextFloat() - 1) * args.js_velocityNoise[1] * m;\n\t\t\t\t\tvelocityInfo[i * 3 + 2] = (2 * rng.nextFloat() - 1) * args.js_velocityNoise[2] * m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar dist = new Vector3();\n\t\tvar ndist = new Vector3();\n\t\tvar pos = new Vector3();\n\t\tvar posRight = new Vector3();\n\t\tvar posLeft = new Vector3();\n\t\tvar posUp = new Vector3();\n\t\tvar posDown = new Vector3();\n\t\tvar relVel = new Vector3();\n\t\tvar f = new Vector3();\n\t\tvar v = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar spatDampForce = new Vector3();\n\t\tvar force = new Vector3(args.js_gravity);\n\t\tvar velo2 = new Vector3();\n\t\tvar restLen2 = Math.sqrt(restLengthX * restLengthX + restLengthY * restLengthY);\n\t\n\t\tvar addForce = function (pos, v, force, stiffness, damping, restLength, x, y, relX, relY, posInfo, velInfo){\n\t\t\tif(\tx + relX > ctx.sizeX - 1 ||\n\t\t\t\ty + relY > ctx.sizeY - 1 ||\n\t\t\t\tx + relX < 0 ||\n\t\t\t\ty + relY < 0) return;\n\t\t\t\t\n\t\t\tvar idx = y * ctx.sizeX + x;\n\t\t\tvar idx2 = (y + relY) * ctx.sizeX + x + relX;\n\t\t\t\n\t\t\tv2.setDirect(\n\t\t\t\tvelocityInfo[idx2*3 + 0],\n\t\t\t\tvelocityInfo[idx2*3 + 1],\n\t\t\t\tvelocityInfo[idx2*3 + 2]\n\t\t\t);\n\t\t\t\t\n\t\t\tposUp.setDirect(\n\t\t\t\tpositionInfo[idx2*3 + 0],\n\t\t\t\tpositionInfo[idx2*3 + 1],\n\t\t\t\tpositionInfo[idx2*3 + 2]\n\t\t\t);\n\t\t\tdist.copy(pos).sub(posUp);\n\t\t\t//Vector3.sub(pos, posUp, dist);\n\t\t\tndist.copy(dist);\n\t\t\tndist.normalize();\n\t\t\tvar len = dist.length();\n\t\t\t//Vector3.sub(v, v2, relVel);\n\t\t\trelVel.copy(v).sub(v2);\n\t\t\t//Vector3.mul((- stiffness * (len - restLength) - damping * relVel.dot(ndist)), ndist, f);\n\t\t\tf.copy(ndist).scale(- stiffness * (len - restLength) - damping * relVel.dot(ndist));\n\t\t\tforce.add(f);\n\t\t}\n\t\t\n\t\tvar getTriangleNormal = function (p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z, target) {\n\t\t\tvar ux = p2x - p1x;\n\t\t\tvar uy = p2y - p1y;\n\t\t\tvar uz = p2z - p1z;\n\t\n\t\t\tvar vx = p3x - p1x;\n\t\t\tvar vy = p3y - p1y;\n\t\t\tvar vz = p3z - p1z;\n\t\n\t\t\ttarget[0] = uy * vz - uz * vy;\n\t\t\ttarget[1] = uz * vx - ux * vz;\n\t\t\ttarget[2] = ux * vy - uy * vx;\n\t\t};\n\t\t\n\t\tvar updateInfo = function (positionInfo, velocityInfo, massInfo, dt){\n\t\t\tvar meshData = ctx.particleEntity.meshDataComponent.meshData;\n\t\t\tvar positions = meshData.getAttributeBuffer(MeshData.POSITION);\n\t\n\t\t\tupdateVelocity(ctx.sizeX, ctx.sizeY, positionInfo, velocityInfo, args.js_gravity, dt, args.js_stiffness, args.js_damping, args.js_bendStiffness, args.js_bendDamping);\n\t\t\tintegrate(ctx.sizeX, ctx.sizeY, positionInfo, velocityInfo, dt);\n\t\t\t\n\t\t\tpositions.set(positionInfo);\n\t\n\t\t\tupdateNormals(meshData,positions);\n\t\n\t\t\tmeshData.setVertexDataUpdated();\n\t\t}\n\t\n\t\tvar updateVelocity = function (nx, ny, posInfo, velInfo, gravity, dt, stiffness, damping, bendStiffness, bendDamping){\n\t\t\tfor (var i = 0; i < nx; i++) {\n\t\t\t\tfor (var j = 0; j < ny; j++) {\n\t\t\t\t\t\n\t\t\t\t\tvar idx = j * nx + i;\n\t\t\t\t\tvar mass = massInfo[idx];\n\t\t\t\t\t\n\t\t\t\t\tif(mass <= 0) continue;\n\t\t\t\t\t\n\t\t\t\t\tforce.setDirect(gravity[0], gravity[1], gravity[2]);\n\t\t\t\t\t\n\t\t\t\t\tpos.setDirect(\n\t\t\t\t\t\tposInfo[idx*3 + 0],\n\t\t\t\t\t\tposInfo[idx*3 + 1],\n\t\t\t\t\t\tposInfo[idx*3 + 2]\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\tvelo2.setDirect(\n\t\t\t\t\t\tvelInfo[idx*3 + 0],\n\t\t\t\t\t\tvelInfo[idx*3 + 1],\n\t\t\t\t\t\tvelInfo[idx*3 + 2]\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\taddForce(pos, velo2, force, stiffness, damping, restLengthY, i, j, 0, 1);\n\t\t\t\t\taddForce(pos, velo2, force, stiffness, damping, restLengthY, i, j, 0, -1);\n\t\t\t\t\t\n\t\t\t\t\taddForce(pos, velo2, force, stiffness, damping, restLengthX, i, j, 1, 0);\n\t\t\t\t\taddForce(pos, velo2, force, stiffness, damping, restLengthX, i, j, -1, 0);\n\t\t\t\t\t\n\t\t\t\t\taddForce(pos, velo2, force, stiffness, damping, restLen2, i, j, 1, 1);\n\t\t\t\t\taddForce(pos, velo2, force, stiffness, damping, restLen2, i, j, 1, -1);\n\t\t\t\t\taddForce(pos, velo2, force, stiffness, damping, restLen2, i, j, -1, 1);\n\t\t\t\t\taddForce(pos, velo2, force, stiffness, damping, restLen2, i, j, -1, -1);\n\t\t\t\t\t\n\t\t\t\t\taddForce(pos, velo2, force, bendStiffness, bendDamping, restLengthX * 2, i, j, 2, 0);\n\t\t\t\t\taddForce(pos, velo2, force, bendStiffness, bendDamping, restLengthX * 2, i, j, -2, 0);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// Spatial damping\n\t\t\t\t\t// force -= spatialDamping * vel.xyz;\n\t\t\t\t\t//spatDampForce.setVector(velo2);\n\t\t\t\t\tspatDampForce.copy(velo2);\n\t\t\t\t\t//spatDampForce.mul(args.js_spatialDamping);\n\t\t\t\t\tspatDampForce.scale(args.js_spatialDamping);\n\t\t\t\t\tforce.sub(spatDampForce);\n\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t//Vector3.mul(force, mass*dt, force);\n\t\t\t\t\tforce.scale(mass * dt);\n\t\t\t\t\tvelo2.add(force);\n\t\t\t\t\tvelInfo[idx*3 + 0] = velo2.x;\n\t\t\t\t\tvelInfo[idx*3 + 1] = velo2.y;\n\t\t\t\t\tvelInfo[idx*3 + 2] = velo2.z;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar setMasses = function (nx, ny, massInfo, invMass){\n\t\t\tfor (var i = 0; i < nx; i++) {\n\t\t\t\tfor (var j = 0; j < ny; j++) {\n\t\t\t\t\t\n\t\t\t\t\tvar idx = j * nx + i;\n\t\t\t\t\tmassInfo[idx] = invMass;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar integrate = function (nx, ny, posInfo, velInfo, dt){\n\t\t\tfor (var i = 0; i !== nx; i++) {\n\t\t\t\tfor (var j = 0; j !== ny; j++) {\n\t\t\t\t\tvar idx = (j * nx + i);\n\t\t\t\t\tvar mass = massInfo[idx];\n\t\t\t\t\t\n\t\t\t\t\tif(mass > 0){\n\t\t\t\t\t\tvar idx3 = 3 * idx;\n\t\t\t\t\t\tfor (var k = idx3; k < idx3 + 3; k++) { // xyz components\n\t\t\t\t\t\t\tpositionInfo[k] += velocityInfo[k] * dt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar tmpArray = [];\n\t\tvar updateNormals = function (meshData, positions){\n\t\t\tvar normals = meshData.getAttributeBuffer(MeshData.NORMAL);\n\t\t\tfor (var i = 0; i < ctx.sizeX; i++) {\n\t\t\t\tfor (var j = 0; j < ctx.sizeY; j++) {\n\t\t\t\t\tvar relX0 = 0,\n\t\t\t\t\t\trelY0 = 0,\n\t\t\t\t\t\trelX1 = 0,\n\t\t\t\t\t\trelY1 = 0,\n\t\t\t\t\t\trelX2 = 0,\n\t\t\t\t\t\trelY2 = 0;\n\t\t\t\t\t\t\n\t\t\t\t\tif(i < ctx.sizeX - 1 && j < ctx.sizeY - 1){\n\t\t\t\t\t\trelY1 = relX2 = 1;\n\t\t\t\t\t} else if(i === ctx.sizeX - 1 && j < ctx.sizeY - 1){\n\t\t\t\t\t\trelX0 = -1;\n\t\t\t\t\t\trelY1 = 1;\n\t\t\t\t\t} else if(i < ctx.sizeX - 1 && j == ctx.sizeY - 1){\n\t\t\t\t\t\trelX0 = 1;\n\t\t\t\t\t\trelY1 = -1;\n\t\t\t\t\t} else if(i == ctx.sizeX - 1 && j == ctx.sizeY - 1){\n\t\t\t\t\t\trelX1 = -1;\n\t\t\t\t\t\trelY0 = -1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar a = ((i+relX0) * ctx.sizeX + (j+relY0)) * 3;\n\t\t\t\t\tvar b = ((i+relX1) * ctx.sizeX + (j+relY1)) * 3;\n\t\t\t\t\tvar c = ((i+relX2) * ctx.sizeX + (j+relY2)) * 3;\n\t\t\t\t\tvar x0 = positions[a + 0],\n\t\t\t\t\t\ty0 = positions[a + 1],\n\t\t\t\t\t\tz0 = positions[a + 2],\n\t\t\t\t\t\t\n\t\t\t\t\t\tx1 = positions[b + 0],\n\t\t\t\t\t\ty1 = positions[b + 1],\n\t\t\t\t\t\tz1 = positions[b + 2],\n\t\t\t\t\t\t\n\t\t\t\t\t\tx2 = positions[c + 0],\n\t\t\t\t\t\ty2 = positions[c + 1],\n\t\t\t\t\t\tz2 = positions[c + 2];\n\t\n\t\t\t\t\tgetTriangleNormal(x0, y0, z0,x1, y1, z1,x2, y2, z2, tmpArray);\n\t\t\t\t\tvar d = (i * ctx.sizeX + j) * 3;\n\t\t\t\t\tnormals[d + 0] = -tmpArray[0];\n\t\t\t\t\tnormals[d + 1] = -tmpArray[1];\n\t\t\t\t\tnormals[d + 2] = -tmpArray[2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tvar particleDemo = function (gooRunner) {\n\t\t\tpositionInfo = [];\n\t\t\tvelocityInfo = [];\n\t\t\tmassInfo = [];\n\t\t\tfillInfo(positionInfo, velocityInfo, massInfo);\n\t\t\t\n\t\t\tvar particleEntity = ctx.particleEntity = createParticleEntity(goo, ctx.sizeX, ctx.sizeY);\n\t\t\tvar first = true;\n\t\n\t\t\tvar startTime = ctx.world.time;\n\t\t\tvar physicsTime = 0;\n\t\t\tvar running = args.js_autoStart;\n\t\t\tctx.callbackPreRender = function (tpf) {\n\t\t\t\tvar currentTime = ctx.world.time - startTime;\n\t\t\t\tif(args.sleepTimeout > 0 && currentTime > args.js_sleepTimeout){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(!running){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(args.js_enableAnimation && !ctx.detached){\n\t\t\t\t\tfillInfo(positionInfo, velocityInfo, massInfo, true);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar dt = 1 / args.js_stepFrequency;\n\t\n\t\t\t\t// Approx num steps needed\n\t\t\t\tvar subSteps = args.js_stepFrequency / 60;\n\t\t\t\tvar usedSubSteps = 0;\n\t\t\t\twhile(physicsTime < currentTime){\n\t\t\t\t\t\n\t\t\t\t\tif(physicsTime > args.js_detach_time && args.js_detach_time > 0 && !ctx.detached){\n\t\t\t\t\t\tsetMasses(ctx.sizeX, ctx.sizeY, massInfo, 1);\n\t\t\t\t\t\tctx.detached = true;\n\t\t\t\t\t\tgoo.SystemBus.emit('clothScript.detach');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tupdateInfo(positionInfo, velocityInfo, massInfo, dt);\n\t\t\t\t\tphysicsTime += dt;\n\t\t\t\t\tusedSubSteps++;\n\t\t\t\t\tif(usedSubSteps >= args.js_maxSubSteps){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tgooRunner.callbacksPreRender.push(ctx.callbackPreRender);\n\t\t\n\t\t\tif(!ctx.materials){\n\t\t\t\tctx.materials = [];\n\t\t\t}\n\t\t\n\t\t\tif(!args.js_autoStart){\n\t\t\t\tctx.startListener = function(){\n\t\t\t\t\trunning = true;\n\t\t\t\t\tphysicsTime = 0;\n\t\t\t\t\tstartTime = ctx.world.time;\n\t\t\t\t}\n\t\t\t\tgoo.SystemBus.addListener('clothScript.start', ctx.startListener);\n\t\t\t}\n\t\t}\n\t\n\t\tvar createParticleEntity = function (goo, sizeX, sizeY) {\n\t\t\tvar count = sizeX * sizeY;\n\t\t\tvar meshData = createClothMesh(ctx.sizeX, ctx.sizeY);\n\t\n\t\t\tvar material = new Material(goo.ShaderLib.uber);\n\t\t\tif(!ctx.materials)\n\t\t\t\tctx.materials = [];\n\t\t\tctx.materials.push(material);\n\t\t\t\n\t\t\treturn createClothEntity(ctx.world, ctx.entity, meshData, material);\n\t\t}\n\t\n\t\tvar init = function () {\n\t\t\tparticleDemo(ctx.world.gooRunner);\n\t\t}\n\t\t\n\t\tinit();\n\t\n\t\tif (args.js_useDeviceGravity && window.DeviceMotionEvent) {\n\t\t\tctx.listeners.devicemotion = function (eventData) {\n\t\t\t\tg = eventData.accelerationIncludingGravity;\n\t\t\t\tvar gs = args.js_deviceGravityScale;\n\t\t\t\tif(g.x !== null){\n\t\t\t\t\targs.js_gravity = [g.x * gs, g.y * gs, g.z * gs];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\t\n\tfor(var eventName in ctx.listeners){\n\t\twindow.addEventListener(eventName, ctx.listeners[eventName]);\n\t}\n};\n\t\nvar cleanup = function(args, ctx, goo) {\n\tvar cbs = ctx.world.gooRunner.callbacksPreRender;\n\tvar idx = cbs.indexOf(ctx.callbackPreRender);\n\tif(idx !== -1){\n\t\tcbs.splice(idx, 1);\n\t}\n\n\tctx.particleEntity.removeFromWorld();\n\n\tfor (var i = 0; ctx.targets && i < ctx.targets.length; i++) {\n\t\tctx.targets[i].destroy(ctx.world.gooRunner.renderer.context);\n\t}\n\tfor (var i = 0; i < ctx.materials.length; i++) {\n\t\tctx.materials[i].shader.destroy();\n\t}\n\n\tctx.entity.meshRendererComponent.hidden = false;\n\t\n\tgoo.SystemBus.removeListener('clothScript.start', ctx.startListener);\n\t\n\tfor(var eventName in ctx.listeners){\n\t\twindow.removeEventListener(eventName, ctx.listeners[eventName]);\n\t}\n};\n\nupdate = function(args, ctx, goo) {\n\tif(\n\t\targs.size !== ctx.currentSize ||\n\t\targs.foldFactor !== ctx.currentFoldFactor ||\n\t\targs.sleepTimeout !== ctx.currentSleepTimeout\n\t){\n\t\tcleanup(args, ctx, goo);\n\t\tsetup(args, ctx, goo);\n\t}\n};\n\t\nvar fallbackModes = ['auto', 'forceJS', 'forceGPU'];\nvar paramModes = ['same', 'different'];\nvar parameters = [];\n\nsetup.presets = {\n\toriginal: {\n\t\tlabel: 'Original',\n\t\tdescription: 'The original velvet drop!',\n\t\tparams: {\n\t\t\tfallbackMode: 'auto',\n\t\t\tparameterMode: 'different',\n\t\t\t\n\t\t\tdamping: 20,\n\t\t\tspatialDamping: 0.4,\n\t\t\tstiffness: 5000,\n\t\t\tbendStiffness: 50,\n\t\t\tbendDamping: 6,\n\t\t\tsize: 6,\n\t\t\tgravity: [0, -1, 0],\n\t\t\tstepFrequency: 200,\n\t\t\tfoldFactor: 0.95,\n\t\t\tvelocityNoise: [0, 0, 0.5],\n\t\t\tsleepTimeout: 20,\n\t\t\tmaxSubSteps: 10,\n\t\t\tuseDeviceGravity: false,\n\t\t\tdeviceGravityScale: -1,\n\t\t\tautoStart: true,\n\t\t\tenableAnimation: false,\n\t\t\tattachmentMode: 'Full top',\n\t\t\tN: 10,\n\t\t\tdetach_time: -1,\n\t\t\t\n\t\t\tjs_damping: 5,\n\t\t\tjs_spatialDamping: 0.5,\n\t\t\tjs_stiffness: 260,\n\t\t\tjs_bendStiffness: 30,\n\t\t\tjs_bendDamping: 6,\n\t\t\tjs_sizeX: 4,\n\t\t\tjs_sizeY: 4,\n\t\t\tjs_gravity: [0, -1, 0],\n\t\t\tjs_stepFrequency: 60,\n\t\t\tjs_foldFactor: 0.95,\n\t\t\tjs_velocityNoise: [0, 0, 0.5],\n\t\t\tjs_sleepTimeout: 15,\n\t\t\tjs_maxSubSteps: 8,\n\t\t\tjs_useDeviceGravity: false,\n\t\t\tjs_deviceGravityScale: -1,\n\t\t\tjs_autoStart: true,\n\t\t\tjs_enableAnimation: false,\n\t\t\tjs_attachmentMode: 'Full top',\n\t\t\tjs_N: 10,\n\t\t\tjs_detach_time: -1\n\t\t}\n\t},\n\t\n\tbouncy: {\n\t\tlabel: 'Bouncy',\n\t\tdescription: 'A bouncier version',\n\t\tparams: {\n\t\t\tfallbackMode: 'auto',\n\t\t\tparameterMode: 'different',\n\t\t\t\n\t\t\tdamping: 4,\n\t\t\tspatialDamping: 0.2,\n\t\t\tstiffness: 800,\n\t\t\tbendStiffness: 5,\n\t\t\tbendDamping: 0.1,\n\t\t\tsize: 5,\n\t\t\tgravity: [0, -0.8, 0],\n\t\t\tstepFrequency: 60,\n\t\t\tfoldFactor: 0.5,\n\t\t\tvelocityNoise: [0, 0, 0],\n\t\t\tsleepTimeout: 30,\n\t\t\tmaxSubSteps: 8,\n\t\t\tuseDeviceGravity: false,\n\t\t\tdeviceGravityScale: -1,\n\t\t\tautoStart: true,\n\t\t\tenableAnimation: false,\n\t\t\tattachmentMode: 'Full top',\n\t\t\tN: 10,\n\t\t\tdetach_time: -1,\n\t\t\t\n\t\t\tjs_damping: 0.3,\n\t\t\tjs_spatialDamping: 0.2,\n\t\t\tjs_stiffness: 300,\n\t\t\tjs_bendStiffness: 30,\n\t\t\tjs_bendDamping: 0.2,\n\t\t\tjs_sizeX: 4,\n\t\t\tjs_sizeY: 4,\n\t\t\tjs_gravity: [0, -1, 0],\n\t\t\tjs_stepFrequency: 60,\n\t\t\tjs_foldFactor: 0.95,\n\t\t\tjs_velocityNoise: [0, 0, 0],\n\t\t\tjs_sleepTimeout: 25,\n\t\t\tjs_maxSubSteps: 8,\n\t\t\tjs_useDeviceGravity: false,\n\t\t\tjs_deviceGravityScale: -1,\n\t\t\tjs_autoStart: true,\n\t\t\tjs_enableAnimation: false,\n\t\t\tjs_attachmentMode: 'Full top',\n\t\t\tjs_N: 10,\n\t\t\tjs_detach_time: -1\n\t\t}\n\t},\n\t\n\tcalm: {\n\t\tlabel: 'Calm',\n\t\tdescription: 'A much calmer version',\n\t\tparams: {\n\t\t\tfallbackMode: 'auto',\n\t\t\tparameterMode: 'different',\n\t\t\t\n\t\t\tdamping: 0,\n\t\t\tspatialDamping: 7,\n\t\t\tstiffness: 4000,\n\t\t\tbendStiffness: 5,\n\t\t\tbendDamping: 1,\n\t\t\tsize: 5,\n\t\t\tgravity: [0, -0.8, 0],\n\t\t\tstepFrequency: 240,\n\t\t\tfoldFactor: 0.2,\n\t\t\tvelocityNoise: [0, 0, 0.001],\n\t\t\tsleepTimeout: 8,\n\t\t\tmaxSubSteps: 8,\n\t\t\tuseDeviceGravity: false,\n\t\t\tdeviceGravityScale: -1,\n\t\t\tautoStart: true,\n\t\t\tenableAnimation: false,\n\t\t\tattachmentMode: 'Full top',\n\t\t\tN: 10,\n\t\t\tdetach_time: -1,\n\t\t\t\n\t\t\tjs_damping: 0,\n\t\t\tjs_spatialDamping: 5,\n\t\t\tjs_stiffness: 300,\n\t\t\tjs_bendStiffness: 30,\n\t\t\tjs_bendDamping: 0.2,\n\t\t\tjs_sizeX: 4,\n\t\t\tjs_sizeY: 4,\n\t\t\tjs_gravity: [0, -0.8, 0],\n\t\t\tjs_stepFrequency: 60,\n\t\t\tjs_foldFactor: 0,\n\t\t\tjs_velocityNoise: [0, 0, 0.001],\n\t\t\tjs_sleepTimeout: 10,\n\t\t\tjs_maxSubSteps: 8,\n\t\t\tjs_useDeviceGravity: false,\n\t\t\tjs_deviceGravityScale: -1,\n\t\t\tjs_autoStart: true,\n\t\t\tjs_enableAnimation: false,\n\t\t\tjs_attachmentMode: 'Full top',\n\t\t\tjs_N: 10,\n\t\t\tjs_detach_time: -1\n\t\t}\n\t},\n\t\n\tperformant: {\n\t\tlabel: 'Performant',\n\t\tdescription: 'Less nodes, but more speed',\n\t\tparams: {\n\t\t\tfallbackMode: 'auto',\n\t\t\tparameterMode: 'different',\n\t\t\t\n\t\t\tdamping: 0.5,\n\t\t\tspatialDamping: 0.4,\n\t\t\tstiffness: 310,\n\t\t\tbendStiffness: 1,\n\t\t\tbendDamping: 0,\n\t\t\tsize: 4,\n\t\t\tgravity: [0, -0.8, 0],\n\t\t\tstepFrequency: 60,\n\t\t\tfoldFactor: 1,\n\t\t\tvelocityNoise: [0, 0, 0],\n\t\t\tsleepTimeout: 20,\n\t\t\tmaxSubSteps: 8,\n\t\t\tuseDeviceGravity: false,\n\t\t\tdeviceGravityScale: -1,\n\t\t\tautoStart: true,\n\t\t\tenableAnimation: false,\n\t\t\tattachmentMode: 'Full top',\n\t\t\tN: 10,\n\t\t\tdetach_time: -1,\n\t\t\t\n\t\t\tjs_damping: 0.2,\n\t\t\tjs_spatialDamping: 0.2,\n\t\t\tjs_stiffness: 60,\n\t\t\tjs_bendStiffness: 60,\n\t\t\tjs_bendDamping: 0.2,\n\t\t\tjs_sizeX: 3,\n\t\t\tjs_sizeY: 3,\n\t\t\tjs_gravity: [0, -0.8, 0],\n\t\t\tjs_stepFrequency: 60,\n\t\t\tjs_foldFactor: 0.95,\n\t\t\tjs_velocityNoise: [0, 0, 0],\n\t\t\tjs_sleepTimeout: 25,\n\t\t\tjs_maxSubSteps: 8,\n\t\t\tjs_useDeviceGravity: false,\n\t\t\tjs_deviceGravityScale: -1,\n\t\t\tjs_autoStart: true,\n\t\t\tjs_enableAnimation: false,\n\t\t\tjs_attachmentMode: 'Full top',\n\t\t\tjs_N: 10,\n\t\t\tjs_detach_time: -1\n\t\t}\n\t},\n\t\n\tunperformant: {\n\t\tlabel: 'Unperformant',\n\t\tdescription: 'More nodes, less speed',\n\t\tparams: {\n\t\t\tfallbackMode: 'auto',\n\t\t\tparameterMode: 'different',\n\t\t\t\n\t\t\tdamping: 10,\n\t\t\tspatialDamping: 3,\n\t\t\tstiffness: 47000,\n\t\t\tbendStiffness: 5000,\n\t\t\tbendDamping: 3,\n\t\t\tsize: 8,\n\t\t\tgravity: [0, -0.8, 0],\n\t\t\tstepFrequency: 500,\n\t\t\tfoldFactor: 0.95,\n\t\t\tvelocityNoise: [0, 0, 0],\n\t\t\tsleepTimeout: 20,\n\t\t\tmaxSubSteps: 8,\n\t\t\tuseDeviceGravity: false,\n\t\t\tdeviceGravityScale: -1,\n\t\t\tautoStart: true,\n\t\t\tenableAnimation: false,\n\t\t\tattachmentMode: 'Full top',\n\t\t\tN: 10,\n\t\t\tdetach_time: -1,\n\t\t\t\n\t\t\tjs_damping: 3,\n\t\t\tjs_spatialDamping: 2,\n\t\t\tjs_stiffness: 500,\n\t\t\tjs_bendStiffness: 60,\n\t\t\tjs_bendDamping: 2,\n\t\t\tjs_sizeX: 5,\n\t\t\tjs_sizeY: 5,\n\t\t\tjs_gravity: [0, -0.8, 0],\n\t\t\tjs_stepFrequency: 60,\n\t\t\tjs_foldFactor: 0.95,\n\t\t\tjs_velocityNoise: [0, 0, 0],\n\t\t\tjs_sleepTimeout: 10,\n\t\t\tjs_maxSubSteps: 8,\n\t\t\tjs_useDeviceGravity: false,\n\t\t\tjs_deviceGravityScale: -1,\n\t\t\tjs_autoStart: true,\n\t\t\tjs_enableAnimation: false,\n\t\t\tjs_attachmentMode: 'Full top',\n\t\t\tjs_N: 10,\n\t\t\tjs_detach_time: -1\n\t\t}\n\t}\n};\n\nif(!advancedSettings){\n\tvar options = [];\n\tfor(var key in setup.presets){\n\t\toptions.push({\n\t\t\tlabel: setup.presets[key].label + ' - ' +  (setup.presets[key].description||''),\n\t\t\tvalue: key\n\t\t});\n\t}\n\tparameters.push({\n\t\tlabel: 'Velvet Drop Type',\n\t\tkey: 'type',\n\t\ttype: 'string',\n\t\tcontrol: 'select',\n\t\toptions: options,\n\t\t'default': 'original'\n\t}, {\n\t\tlabel: 'Detach after 7s',\n\t\tkey: 'detach',\n\t\ttype: 'boolean',\n\t\t'default': false\n\t});\n} else {\n\tparameters.push({\n\t    name: 'fallbackMode',\n\t    key: 'fallbackMode',\n\t    type: 'string',\n\t    control: 'select',\n\t    options: fallbackModes,\n\t    default: fallbackModes[0],\n\t    description: 'Auto will pick JS/GPU depending on platform. You can also force use of either JS or GPU, for testing.'\n\t},{\n\t    name: 'parameterMode',\n\t    key: 'parameterMode',\n\t    type: 'string',\n\t    control: 'select',\n\t    options: paramModes,\n\t    default: paramModes[0],\n\t    description: 'same: use same parameters for both GPU and JS simulations, the unprefixed ones will be used.'\n\t},\n\t\n\t\n\t\n\t\n\t\n\t\n\t{\n\t\tkey: 'damping',\n\t\tname:'damping',\n\t\ttype:'float',\n\t\t'default': 10,\n\t\tmin:0,\n\t\tdescription:'Damping along fiber springs'\n\t},{\n\t\tkey: 'spatialDamping',\n\t\tname:'spatialDamping',\n\t\ttype:'float',\n\t\t'default': 1,\n\t\tmin:0,\n\t\tdescription:'Spatial damping'\n\t},{\n\t\tkey: 'stiffness',\n\t\tname:'stiffness',\n\t\ttype:'float',\n\t\t'default': 1000,\n\t\tmin: 0,\n\t\tdescription:'Stiffness of fiber springs'\n\t},{\n\t\tkey: 'bendStiffness',\n\t\tname:'bendStiffness',\n\t\ttype:'float',\n\t\t'default': 100,\n\t\tmin: 0,\n\t\tdescription:'Stiffness of bending springs'\n\t},{\n\t\tkey: 'bendDamping',\n\t\tname:'bendDamping',\n\t\ttype:'float',\n\t\t'default': 10,\n\t\tmin:0,\n\t\tdescription:'Damping along bending springs'\n\t},{\n\t\tkey: 'size',\n\t\tname:'size',\n\t\ttype:'int',\n\t\t'default': 5,\n\t\tmin: 2,\n\t\tdescription: 'Number of particles = size^2 * size^2'\n\t},{\n\t\tkey: 'gravity',\n\t\tname:'gravity',\n\t\ttype:'vec3',\n\t\t'default': [0, -1, 1],\n\t\tdescription: 'Gravity vector'\n\t},{\n\t\tkey: 'stepFrequency',\n\t\tname:'stepFrequency',\n\t\ttype:'int',\n\t\t'default': 120,\n\t\tmin:1,\n\t\tdescription: 'Time stepping frequency. Increase if your cloth explodes.'\n\t},{\n\t\tkey: 'foldFactor',\n\t\tname:'foldFactor',\n\t\ttype:'float',\n\t\t'default': 1,\n\t\tmax:1,\n\t\tmin:0,\n\t\tdescription: '0 = not folded, 1 = fully folded.'\n\t},{\n\t\tkey: 'velocityNoise',\n\t\tname:'velocityNoise',\n\t\ttype:'vec3',\n\t\t'default': [0, 0, 0],\n\t\tdescription: 'Initial randomness along each world axis of the velocities. If zero, no randomness.'\n\t},{\n\t\tkey: 'sleepTimeout',\n\t\tname:'sleepTimeout',\n\t\ttype:'float',\n\t\t'default': -1,\n\t\tdescription: 'Time to wait before sleeping. Set to -1 to not sleep at all.'\n\t},{\n\t\tkey: 'maxSubSteps',\n\t\tname:'maxSubSteps',\n\t\ttype:'int',\n\t\t'default': 10,\n\t\tmin: 1,\n\t\tdescription: 'Max sub timesteps to do to catch up with the wall clock.'\n\t},{\n\t\tkey: 'useDeviceGravity',\n\t\tname:'useDeviceGravity',\n\t\ttype:'boolean',\n\t\t'default': false,\n\t\tdescription: 'Whether to use accelerometer data.'\n\t},{\n\t\tkey: 'deviceGravityScale',\n\t\tname:'deviceGravityScale',\n\t\ttype:'float',\n\t\t'default': -1,\n\t\tdescription: 'Used to scale the incoming gravity data.'\n\t},{\n\t\tkey: 'autoStart',\n\t\tname:'autoStart',\n\t\ttype:'boolean',\n\t\t'default': true,\n\t\tdescription: 'If false, you must start the simulation via the SystemBus event: clothScript.start'\n\t},{\n\t\tkey: 'enableAnimation',\n\t\tname:'enableAnimation',\n\t\ttype:'boolean',\n\t\t'default': false,\n\t\tdescription: 'Set to true if you intend to, for example, tween move the cloth entity.'\n\t},{\n\t\tkey: 'attachmentMode',\n\t\tname: 'attachmentMode',\n\t\ttype: 'string',\n\t\tcontrol: 'select',\n\t\t'default': 'Full top',\n\t\toptions: ['Full top', '2 points at top', 'N points at top', 'None'],\n\t\tdescription: 'What points to fix.'\n\t},{\n\t\tkey: 'N',\n\t\tname: 'N',\n\t\ttype: 'float',\n\t\t'default': 10,\n\t\tmin:0\n\t},{\n\t\tkey: 'detach_time',\n\t\tname: 'Detach time',\n\t\tdescription: 'Time until detachment. Set to -1 if you dont want to detach.',\n\t\ttype: 'float',\n\t\t'default': -1\n\t},\n\t\n\t\n\t\n\t\n\t{\n\t\tkey: 'js_damping',\n\t\tname:'js_damping',\n\t\ttype:'float',\n\t\t'default': 10,\n\t\tmin:0,\n\t\tdescription:'Damping along fiber springs'\n\t},{\n\t\tkey: 'js_spatialDamping',\n\t\tname:'js_spatialDamping',\n\t\ttype:'float',\n\t\t'default': 1,\n\t\tmin:0,\n\t\tdescription:'Spatial damping'\n\t},{\n\t\tkey: 'js_stiffness',\n\t\tname:'js_stiffness',\n\t\ttype:'float',\n\t\t'default': 1000,\n\t\tmin: 0,\n\t\tdescription:'Stiffness of fiber springs'\n\t},{\n\t\tkey: 'js_bendStiffness',\n\t\tname:'js_bendStiffness',\n\t\ttype:'float',\n\t\t'default': 100,\n\t\tmin: 0,\n\t\tdescription:'Stiffness of bending springs'\n\t},{\n\t\tkey: 'js_bendDamping',\n\t\tname:'js_bendDamping',\n\t\ttype:'float',\n\t\t'default': 10,\n\t\tmin:0,\n\t\tdescription:'Damping along bending springs'\n\t},{\n\t\tkey: 'js_sizeX',\n\t\tname:'js_sizeX',\n\t\ttype:'int',\n\t\t'default': 5,\n\t\tmin: 2,\n\t\tdescription: 'Number of particles = size^2 * size^2'\n\t},{\n\t\tkey: 'js_sizeY',\n\t\tname:'js_sizeY',\n\t\ttype:'int',\n\t\t'default': 5,\n\t\tmin: 2,\n\t\tdescription: 'Number of particles = size^2 * size^2'\n\t},{\n\t\tkey: 'js_gravity',\n\t\tname:'js_gravity',\n\t\ttype:'vec3',\n\t\t'default': [0, -1, 1],\n\t\tdescription: 'Gravity vector'\n\t},{\n\t\tkey: 'js_stepFrequency',\n\t\tname:'js_stepFrequency',\n\t\ttype:'int',\n\t\t'default': 120,\n\t\tmin:1,\n\t\tdescription: 'Time stepping frequency. Increase if your cloth explodes.'\n\t},{\n\t\tkey: 'js_foldFactor',\n\t\tname:'js_foldFactor',\n\t\ttype:'float',\n\t\t'default': 1,\n\t\tmax:1,\n\t\tmin:0,\n\t\tdescription: '0 = not folded, 1 = fully folded.'\n\t},{\n\t\tkey: 'js_velocityNoise',\n\t\tname:'js_velocityNoise',\n\t\ttype:'vec3',\n\t\t'default': [0, 0, 0],\n\t\tdescription: 'Initial randomness along each world axis of the velocities. If zero, no randomness.'\n\t},{\n\t\tkey: 'js_sleepTimeout',\n\t\tname:'js_sleepTimeout',\n\t\ttype:'float',\n\t\t'default': -1,\n\t\tdescription: 'Time to wait before sleeping. Set to -1 to not sleep at all.'\n\t},{\n\t\tkey: 'js_maxSubSteps',\n\t\tname:'js_maxSubSteps',\n\t\ttype:'int',\n\t\t'default': 10,\n\t\tmin: 1,\n\t\tdescription: 'Max sub timesteps to do to catch up with the wall clock.'\n\t},{\n\t\tkey: 'js_useDeviceGravity',\n\t\tname:'js_useDeviceGravity',\n\t\ttype:'boolean',\n\t\t'default': false,\n\t\tdescription: 'Whether to use accelerometer data.'\n\t},{\n\t\tkey: 'js_deviceGravityScale',\n\t\tname:'js_deviceGravityScale',\n\t\ttype:'float',\n\t\t'default': -1,\n\t\tdescription: 'Used to scale the incoming gravity data.'\n\t},{\n\t\tkey: 'js_autoStart',\n\t\tname:'js_autoStart',\n\t\ttype:'boolean',\n\t\t'default': true,\n\t\tdescription: 'If false, you must start the simulation via the SystemBus event: clothScript.start'\n\t},{\n\t\tkey: 'js_enableAnimation',\n\t\tname:'js_enableAnimation',\n\t\ttype:'boolean',\n\t\t'default': false,\n\t\tdescription: 'Set to true if you intend to, for example, tween move the cloth entity.'\n\t},{\n\t\tkey: 'js_attachmentMode',\n\t\tname: 'js_Attachment mode',\n\t\ttype: 'string',\n\t\tcontrol: 'select',\n\t\t'default': 'Full top',\n\t\toptions: ['Full top', '2 points at top', 'N points at top', 'None'],\n\t\tdescription: 'What points to fix.'\n\t},{\n\t\tkey: 'js_N',\n\t\tname: 'js_N',\n\t\ttype: 'float',\n\t\t'default': 10,\n\t\tmin:0\n\t},{\n\t\tkey: 'js_detach_time',\n\t\tname: 'js_detach_time',\n\t\tdescription: 'Time until detachment. Set to -1 if you dont want to detach.',\n\t\ttype: 'float',\n\t\t'default': -1\n\t});\n}", "name": "Cloth Script", "license": "CC0", "created": "2015-05-06T13:49:07.703113+00:00", "deleted": false, "dataModelVersion": 2, "modified": "2015-05-06T13:49:07.703113+00:00", "dependencies": {}, "id": "0ea623cf941242e3a09da5adbf8fb299.script"}, "78de32fcb665490da74753058d21f162.entity": {"name": "Fixed Cam", "license": "CC0", "created": "2015-05-06T13:49:08.129875+00:00", "deleted": false, "tags": {}, "dataModelVersion": 2, "modified": "2015-05-06T13:49:08.129875+00:00", "static": false, "components": {"camera": {"fov": 45, "lockedRatio": false, "far": 1000, "projectionMode": "Perspective", "near": 1, "aspect": 1, "size": 100}, "transform": {"rotation": [0, 0, 0], "scale": [1, 1, 1], "translation": [0, -0.09254765510559082, 1.722010850906372]}, "script": {"scripts": {"05ec93c4e2f74341b248f0c4081f86f5.scriptInstance": {"scriptRef": "62f28be176f54cfcb6b9b6b7714af000.script", "options": {"enabled": false}, "id": "05ec93c4e2f74341b248f0c4081f86f5.scriptInstance", "sortValue": 0, "name": "Instance of Script"}}}}, "hidden": false, "id": "78de32fcb665490da74753058d21f162.entity"}, "cd97715a811c4beaaa5a5fa2fcb96fa6.environment": {"sound": {"dopplerFactor": 0, "muted": false, "volume": 1, "rolloffFactor": 0.4, "reverb": 0, "maxDistance": 100}, "globalAmbient": [0, 0, 0, 0], "license": "CC0", "created": "2015-05-06T13:49:08.178186+00:00", "deleted": false, "dataModelVersion": 2, "modified": "2015-05-06T13:49:08.178186+00:00", "fog": {"color": [0, 0, 0], "far": 5, "near": 4, "enabled": false}, "backgroundColor": [0, 0, 0, 1], "weather": {"snow": {"velocity": 10, "rate": 10, "enabled": false, "height": 25}}, "id": "cd97715a811c4beaaa5a5fa2fcb96fa6.environment", "name": "Default Environment"}, "7f3a54d7f33d4dee9022a3447f3f762d.material": {"texturesMapping": {"DIFFUSE_MAP": {"enabled": true, "textureRef": "a799b480a5174dde95fda4d7a856e00e.texture"}, "LOCAL_ENVIRONMENT": {"enabled": true, "textureRef": "9a1d2d115002410eacf549d5c0a511be.texture"}}, "flat": false, "cullState": {"frontFace": "CCW", "enabled": false, "cullFace": "Back"}, "uniforms": {"opacity": {"enabled": false, "value": 1}, "refractivity": {"enabled": false, "value": 0}, "materialAmbient": {"enabled": true, "value": [0.44313725490196076, 0.44313725490196076, 0.44313725490196076, 1]}, "materialSpecular": {"enabled": true, "value": [0.39583333333333337, 0.39583333333333337, 0.39583333333333337, 1]}, "fresnel": {"enabled": true, "value": 0.29}, "reflectivity": {"enabled": true, "value": 1}, "materialSpecularPower": {"enabled": true, "value": 30.32}, "materialDiffuse": {"enabled": true, "value": [0.7176470588235294, 0.7176470588235294, 0.7176470588235294, 1]}, "vertexColorAmount": {"enabled": true, "value": 1}, "materialEmissive": {"enabled": true, "value": [0, 0, 0, 1]}, "discardThreshold": {"enabled": false, "value": 0}, "normalMultiplier": {"enabled": true, "value": 0}, "etaRatio": {"enabled": true, "value": -0.5}, "reflectionType": 1, "wrapSettings": {"enabled": true, "value": [0.54, 0.53]}}, "name": "Goo Cloth material", "license": "CC0", "created": "2015-05-06T13:49:07.730306+00:00", "deleted": false, "wireframe": false, "dataModelVersion": 2, "blendState": {"blendEquation": "AddEquation", "blendSrc": "SrcAlphaFactor", "blendDst": "OneMinusSrcAlphaFactor", "blending": "NoBlending"}, "modified": "2015-06-09T13:20:23.706740+00:00", "dualTransparency": false, "depthState": {"write": true, "enabled": true}, "shaderRef": "GOO_ENGINE_SHADERS/uber", "id": "7f3a54d7f33d4dee9022a3447f3f762d.material", "renderQueue": 2341}, "5b48b55d28ec414187280d095d24aa8e.entity": {"name": "Light Cone 2", "license": "CC0", "created": "2015-05-06T13:49:07.978646+00:00", "deleted": false, "tags": {}, "dataModelVersion": 2, "modified": "2015-05-06T13:49:07.978646+00:00", "static": false, "components": {"light": {"direction": [0, 0, 0], "shadowCaster": false, "color": [1, 1, 1, 1], "intensity": 0.4, "range": 50, "specularIntensity": 1, "penumbra": 5, "angle": 50, "type": "SpotLight", "shadowSettings": {"fov": 50, "darkness": 1, "far": 50, "near": 1, "resolution": [256, 256], "shadowType": "Basic", "size": 100}}, "transform": {"translation": [0.9, 0.2, 1.4], "scale": [1, 1, 1], "rotation": [0, 0, 0]}, "script": {"scripts": {"a953bf79bae4416591c10b6cabf5dd97.scriptInstance": {"scriptRef": "61b0712a48d74282b57b5ce2134229ff.script", "name": "Custom script", "sortValue": 0, "options": {"offset": [0, 0, 0], "enabled": true, "lerp": 0.1}}}}}, "hidden": false, "id": "5b48b55d28ec414187280d095d24aa8e.entity"}, "ed658b2ea2ed4f9784ad6420cd7ffca2.posteffects": {"name": "Post effects", "license": "CC0", "created": "2015-05-06T13:49:07.650897+00:00", "deleted": false, "dataModelVersion": 2, "posteffects": {}, "modified": "2015-05-06T13:49:07.650897+00:00", "id": "ed658b2ea2ed4f9784ad6420cd7ffca2.posteffects"}, "62f28be176f54cfcb6b9b6b7714af000.script": {"body": "/* global gsrv */\n\n\"use strict\";\n\n// Closes the expandable ad via Serve.js SafeFrame API if it is loaded.\nvar setup = function(args, ctx, goo) {\n\tctx.closed = false;\n\tctx.startTime = ctx.world.time;\n};\n\nvar update = function(args, ctx, goo) {\n\tif (!ctx.closed && ctx.world.time - ctx.startTime > args.closeTimeout && window.gsrv && gsrv.sf) {\n\t\tctx.closed = true;\n\t\tgsrv.sf.close();\n\t}\n};\n\nvar parameters = {\n\tkey: 'closeTimeout',\n\ttype: 'number',\n\t'default': 15\n};", "name": "Close Script", "license": "CC0", "created": "2015-11-04T16:23:30.086Z", "deleted": false, "dataModelVersion": 2, "modified": "2015-11-04T16:23:30.086Z", "id": "62f28be176f54cfcb6b9b6b7714af000.script"}, "f957bf5d95ef489e9490e0ff59ffa1ce.entity": {"name": "Light Cone 1", "license": "CC0", "created": "2015-05-06T13:49:08.030363+00:00", "deleted": false, "tags": {}, "dataModelVersion": 2, "modified": "2015-05-06T13:49:08.030363+00:00", "static": false, "components": {"light": {"direction": [0, 0, 0], "shadowCaster": false, "color": [1, 1, 1, 1], "intensity": 0.4, "range": 50, "specularIntensity": 1, "penumbra": 5, "angle": 50, "type": "SpotLight", "shadowSettings": {"fov": 50, "darkness": 1, "far": 50, "near": 1, "resolution": [256, 256], "shadowType": "Basic", "size": 100}}, "transform": {"translation": [-0.9, 0.2, 1.4], "scale": [1, 1, 1], "rotation": [0, 0, 0]}, "script": {"scripts": {"a953bf79bae4416591c10b6cabf5dd97.scriptInstance": {"scriptRef": "61b0712a48d74282b57b5ce2134229ff.script", "name": "Custom script", "sortValue": 0, "options": {"offset": [0, 0, 0], "enabled": true, "lerp": 0.1}}}}}, "hidden": false, "id": "f957bf5d95ef489e9490e0ff59ffa1ce.entity"}, "61b0712a48d74282b57b5ce2134229ff.script": {"body": "var setup = function(args, ctx, goo) {\n\tctx.x = null;\n\tctx.y = null;\n\tctx.dirty = false;\n\n\tctx.clothPos = ctx.world.by.tag('cloth').first().getTranslation();\n\tctx.targetPos = new goo.Vector3(ctx.clothPos);\n\tctx.currentPos = new goo.Vector3(ctx.clothPos);\n\tctx.offset = new goo.Vector3(args.offset);\n\t\n\tctx.depth = Math.abs(ctx.activeCameraEntity.getTranslation().z - ctx.clothPos.z);\n\n\tctx.listeners = {\n\t\tmousemove: function(evt) {\n\t\t\tctx.x = evt.offsetX;\n\t\t\tctx.y = evt.offsetY;\n\t\t\tctx.dirty = true;\n\t\t},\n\t\tmouseleave: function() {\n\t\t\tctx.x = null;\n\t\t\tctx.y = null;\n\t\t\tctx.dirty = true;\n\t\t},\n\t\ttouchmove: function(evt) {\n\t\t\tctx.x = evt.touches[0].clientX;\n\t\t\tctx.y = evt.touches[0].clientY;\n\t\t\tctx.dirty = true;\n\t\t}\n\t}\n\tctx.listeners.touchleave = ctx.listeners.mouseleave;\n\t\n\tfor (var type in ctx.listeners) {\n\t\tctx.domElement.addEventListener(type, ctx.listeners[type]);\n\t}\n};\nvar cleanup = function(args, ctx, goo) {\n\tfor (var type in ctx.listeners) {\n\t\tctx.domElement.removeEventListener(type, ctx.listeners[type]);\n\t}\n};\n\nvar update = function(args, ctx, goo) {\n\tif (ctx.dirty) {\n\t\tif (ctx.x !== null && ctx.y !== null) {\n\t\t\tctx.depth = Math.abs(ctx.activeCameraEntity.getTranslation().z - ctx.clothPos.z);\n\t\t\tvar cam = ctx.activeCameraEntity.cameraComponent.camera;\n\t\t\tvar dpx = ctx.world.gooRunner.renderer.devicePixelRatio;\n\t\t\tcam.getWorldPosition(ctx.x, ctx.y, ctx.viewportWidth / dpx, ctx.viewportHeight / dpx, ctx.depth, ctx.targetPos);\n\t\t} else {\n\t\t\tctx.targetPos.copy(ctx.clothPos);\n\t\t}\n\t\tctx.targetPos.add(ctx.offset);\n\t\tctx.dirty = false;\n\t}\n\tctx.currentPos.lerp(ctx.targetPos, args.lerp);\n\tctx.entity.transformComponent.transform.lookAt(ctx.currentPos, goo.Vector3.UNIT_Y);\n\tctx.entity.transformComponent.setUpdated();\n};\n\nvar parameters = [{\n\tkey: 'lerp',\n\ttype: 'float',\n\tmin: 0,\n\tmax: 1,\n\tcontrol: 'slider',\n\t'default': 0.8\n}, {\n\tkey: 'offset',\n\ttype: 'vec3',\n\t'default': [0,0,0]\n}];", "name": "Follow mouse", "license": "CC0", "created": "2015-05-06T13:49:08.080659+00:00", "deleted": false, "dataModelVersion": 2, "modified": "2015-05-06T13:49:08.080659+00:00", "dependencies": {}, "id": "61b0712a48d74282b57b5ce2134229ff.script"}, "43bf7dd8e2e24b05a1438c4c9bd38de2.entity": {"name": "Cloth", "license": "CC0", "created": "2015-05-06T13:49:07.779954+00:00", "deleted": false, "tags": {"cloth": "cloth"}, "dataModelVersion": 2, "modified": "2015-05-06T13:49:07.779954+00:00", "static": false, "components": {"script": {"scripts": {"01650fe1cf864e60b0fe312549e2a0f8.scriptInstance": {"scriptRef": "0ea623cf941242e3a09da5adbf8fb299.script", "options": {"type": "original", "detach": false, "enabled": true}, "id": "01650fe1cf864e60b0fe312549e2a0f8.scriptInstance", "sortValue": 3, "name": "Custom script"}, "0ada05cf91e34b29a919094111085c76.scriptInstance": {"scriptRef": "aa0688298282428397645955e4e34e3a.script", "options": {"enabled": true}, "id": "0ada05cf91e34b29a919094111085c76.scriptInstance", "sortValue": 1, "name": "Custom script"}}}, "transform": {"rotation": [6.494335535031707, 0, 0], "scale": [1.2448590993881226, 0.49075597524642944, 0.13737064599990845], "translation": [0, 0.2900618612766266, 0.20681551098823547]}, "meshRenderer": {"reflectable": true, "materials": {"7f3a54d7f33d4dee9022a3447f3f762d.material": {"materialRef": "7f3a54d7f33d4dee9022a3447f3f762d.material", "sortValue": 0}}, "receiveShadows": true, "cullMode": "Dynamic", "castShadows": true}, "meshData": {"shape": "Quad"}}, "hidden": false, "id": "43bf7dd8e2e24b05a1438c4c9bd38de2.entity"}, "9a1d2d115002410eacf549d5c0a511be.texture": {"wrapS": "Repeat", "minFilter": "Trilinear", "name": "1x1Gray95.png", "license": "CC0", "flipY": true, "deleted": false, "magFilter": "Bilinear", "created": "2015-05-06T13:49:07.877757+00:00", "dataModelVersion": 2, "modified": "2015-06-09T13:18:39.671405+00:00", "repeat": [1, 1], "imageRef": "24b6c9a1b66764eaa9ef05863122cf059789d278.png", "lodBias": 0, "offset": [0, 0], "id": "9a1d2d115002410eacf549d5c0a511be.texture", "generateMipmaps": true, "anisotropy": 1, "wrapT": "Repeat"}, "a799b480a5174dde95fda4d7a856e00e.texture": {"wrapS": "Repeat", "minFilter": "Trilinear", "name": "goo_v02.png", "license": "CC0", "flipY": true, "deleted": false, "magFilter": "Bilinear", "created": "2015-06-09T13:20:21.826145+00:00", "dataModelVersion": 2, "originalAsset": {"version": "270c3638a60240aa815524aae6304604", "id": "d93dd19c0ce04671b56a8b47c755738d"}, "modified": "2015-06-09T13:20:58.931245+00:00", "matchFileName": "drop.jpg", "repeat": [1, 1], "imageRef": "539587da49c81dddeb8a5484118266771db69f4a.png", "lodBias": 0, "offset": [0, 0], "generateMipmaps": true, "wrapT": "Repeat", "id": "a799b480a5174dde95fda4d7a856e00e.texture", "anisotropy": 1}, "aa0688298282428397645955e4e34e3a.script": {"body": "var setup = function(args, ctx, goo) {\n\tctx.click = function() {\n\t\tgsrv.exit('default');\n\t};\n\tctx.domElement.addEventListener('click', ctx.click);\n};\n\nvar cleanup = function(args, ctx, goo) {\n\tctx.domElement.removeEventListener('click', ctx.click);\n};\n", "name": "Click Through", "license": "CC0", "created": "2015-05-06T13:49:07.927513+00:00", "deleted": false, "modified": "2015-05-06T13:49:07.927513+00:00", "dataModelVersion": 2, "dependencies": {}, "id": "aa0688298282428397645955e4e34e3a.script"}}